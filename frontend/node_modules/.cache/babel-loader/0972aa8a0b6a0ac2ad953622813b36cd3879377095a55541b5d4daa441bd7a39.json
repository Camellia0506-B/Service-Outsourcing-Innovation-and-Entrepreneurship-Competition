{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n// src/dom/methods/hasClass.ts\nfunction hasClass(element, className) {\n  if (element) {\n    if (element.classList) return element.classList.contains(className);else return new RegExp(\"(^| )\" + className + \"( |$)\", \"gi\").test(element.className);\n  }\n  return false;\n}\n\n// src/dom/methods/addClass.ts\nfunction addClass(element, className) {\n  if (element && className) {\n    const fn = _className => {\n      if (!hasClass(element, _className)) {\n        if (element.classList) element.classList.add(_className);else element.className += \" \" + _className;\n      }\n    };\n    [className].flat().filter(Boolean).forEach(_classNames => _classNames.split(\" \").forEach(fn));\n  }\n}\n\n// src/dom/methods/calculateBodyScrollbarWidth.ts\nfunction calculateBodyScrollbarWidth() {\n  return window.innerWidth - document.documentElement.offsetWidth;\n}\n\n// src/dom/helpers/blockBodyScroll.ts\nfunction blockBodyScroll(option) {\n  if (typeof option === \"string\") {\n    addClass(document.body, option || \"p-overflow-hidden\");\n  } else {\n    (option == null ? void 0 : option.variableName) && document.body.style.setProperty(option.variableName, calculateBodyScrollbarWidth() + \"px\");\n    addClass(document.body, (option == null ? void 0 : option.className) || \"p-overflow-hidden\");\n  }\n}\n\n// src/dom/helpers/saveAs.ts\nfunction saveAs(file) {\n  if (file) {\n    const link = document.createElement(\"a\");\n    if (link.download !== void 0) {\n      const {\n        name,\n        src\n      } = file;\n      link.setAttribute(\"href\", src);\n      link.setAttribute(\"download\", name);\n      link.style.display = \"none\";\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/dom/helpers/exportCSV.ts\nfunction exportCSV(csv, filename) {\n  const blob = new Blob([csv], {\n    type: \"application/csv;charset=utf-8;\"\n  });\n  if (window.navigator.msSaveOrOpenBlob) {\n    navigator.msSaveOrOpenBlob(blob, filename + \".csv\");\n  } else {\n    const isDownloaded = saveAs({\n      name: filename + \".csv\",\n      src: URL.createObjectURL(blob)\n    });\n    if (!isDownloaded) {\n      csv = \"data:text/csv;charset=utf-8,\" + csv;\n      window.open(encodeURI(csv));\n    }\n  }\n}\n\n// src/dom/methods/removeClass.ts\nfunction removeClass(element, className) {\n  if (element && className) {\n    const fn = _className => {\n      if (element.classList) element.classList.remove(_className);else element.className = element.className.replace(new RegExp(\"(^|\\\\b)\" + _className.split(\" \").join(\"|\") + \"(\\\\b|$)\", \"gi\"), \" \");\n    };\n    [className].flat().filter(Boolean).forEach(_classNames => _classNames.split(\" \").forEach(fn));\n  }\n}\n\n// src/dom/helpers/unblockBodyScroll.ts\nfunction unblockBodyScroll(option) {\n  if (typeof option === \"string\") {\n    removeClass(document.body, option || \"p-overflow-hidden\");\n  } else {\n    if (option == null ? void 0 : option.variableName) document.body.style.removeProperty(option.variableName);\n    removeClass(document.body, (option == null ? void 0 : option.className) || \"p-overflow-hidden\");\n  }\n}\n\n// src/dom/methods/getCSSVariableByRegex.ts\nfunction getCSSVariableByRegex(variableRegex) {\n  for (const sheet of document == null ? void 0 : document.styleSheets) {\n    try {\n      for (const rule of sheet == null ? void 0 : sheet.cssRules) {\n        for (const property of rule == null ? void 0 : rule.style) {\n          if (variableRegex.test(property)) {\n            return {\n              name: property,\n              value: rule.style.getPropertyValue(property).trim()\n            };\n          }\n        }\n      }\n    } catch (e) {}\n  }\n  return null;\n}\n\n// src/dom/methods/getHiddenElementDimensions.ts\nfunction getHiddenElementDimensions(element) {\n  const dimensions = {\n    width: 0,\n    height: 0\n  };\n  if (element) {\n    element.style.visibility = \"hidden\";\n    element.style.display = \"block\";\n    dimensions.width = element.offsetWidth;\n    dimensions.height = element.offsetHeight;\n    element.style.display = \"none\";\n    element.style.visibility = \"visible\";\n  }\n  return dimensions;\n}\n\n// src/dom/methods/getViewport.ts\nfunction getViewport() {\n  const win = window,\n    d = document,\n    e = d.documentElement,\n    g = d.getElementsByTagName(\"body\")[0],\n    w = win.innerWidth || e.clientWidth || g.clientWidth,\n    h = win.innerHeight || e.clientHeight || g.clientHeight;\n  return {\n    width: w,\n    height: h\n  };\n}\n\n// src/dom/methods/getScrollLeft.ts\nfunction getScrollLeft(element) {\n  return element ? Math.abs(element.scrollLeft) : 0;\n}\n\n// src/dom/methods/getWindowScrollLeft.ts\nfunction getWindowScrollLeft() {\n  const doc = document.documentElement;\n  return (window.pageXOffset || getScrollLeft(doc)) - (doc.clientLeft || 0);\n}\n\n// src/dom/methods/getWindowScrollTop.ts\nfunction getWindowScrollTop() {\n  const doc = document.documentElement;\n  return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n}\n\n// src/dom/methods/absolutePosition.ts\nfunction absolutePosition(element, target, gutter = true) {\n  var _a, _b, _c, _d;\n  if (element) {\n    const elementDimensions = element.offsetParent ? {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    } : getHiddenElementDimensions(element);\n    const elementOuterHeight = elementDimensions.height;\n    const elementOuterWidth = elementDimensions.width;\n    const targetOuterHeight = target.offsetHeight;\n    const targetOuterWidth = target.offsetWidth;\n    const targetOffset = target.getBoundingClientRect();\n    const windowScrollTop = getWindowScrollTop();\n    const windowScrollLeft = getWindowScrollLeft();\n    const viewport = getViewport();\n    let top,\n      left,\n      origin = \"top\";\n    if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {\n      top = targetOffset.top + windowScrollTop - elementOuterHeight;\n      origin = \"bottom\";\n      if (top < 0) {\n        top = windowScrollTop;\n      }\n    } else {\n      top = targetOuterHeight + targetOffset.top + windowScrollTop;\n    }\n    if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);else left = targetOffset.left + windowScrollLeft;\n    element.style.top = top + \"px\";\n    element.style.insetInlineStart = left + \"px\";\n    element.style.transformOrigin = origin;\n    if (gutter) element.style.marginTop = origin === \"bottom\" ? `calc(${(_b = (_a = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a.value) != null ? _b : \"2px\"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : \"\";\n  }\n}\n\n// src/dom/methods/addStyle.ts\nfunction addStyle(element, style) {\n  if (element) {\n    if (typeof style === \"string\") {\n      element.style.cssText = style;\n    } else {\n      Object.entries(style || {}).forEach(([key, value]) => element.style[key] = value);\n    }\n  }\n}\n\n// src/dom/methods/getOuterWidth.ts\nfunction getOuterWidth(element, margin) {\n  if (element instanceof HTMLElement) {\n    let width = element.offsetWidth;\n    if (margin) {\n      const style = getComputedStyle(element);\n      width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n    }\n    return width;\n  }\n  return 0;\n}\n\n// src/dom/methods/relativePosition.ts\nfunction relativePosition(element, target, gutter = true) {\n  var _a, _b, _c, _d;\n  if (element) {\n    const elementDimensions = element.offsetParent ? {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    } : getHiddenElementDimensions(element);\n    const targetHeight = target.offsetHeight;\n    const targetOffset = target.getBoundingClientRect();\n    const viewport = getViewport();\n    let top,\n      left,\n      origin = \"top\";\n    if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {\n      top = -1 * elementDimensions.height;\n      origin = \"bottom\";\n      if (targetOffset.top + top < 0) {\n        top = -1 * targetOffset.top;\n      }\n    } else {\n      top = targetHeight;\n    }\n    if (elementDimensions.width > viewport.width) {\n      left = targetOffset.left * -1;\n    } else if (targetOffset.left + elementDimensions.width > viewport.width) {\n      left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;\n    } else {\n      left = 0;\n    }\n    element.style.top = top + \"px\";\n    element.style.insetInlineStart = left + \"px\";\n    element.style.transformOrigin = origin;\n    gutter && (element.style.marginTop = origin === \"bottom\" ? `calc(${(_b = (_a = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _a.value) != null ? _b : \"2px\"} * -1)` : (_d = (_c = getCSSVariableByRegex(/-anchor-gutter$/)) == null ? void 0 : _c.value) != null ? _d : \"\");\n  }\n}\n\n// src/dom/methods/alignOverlay.ts\nfunction alignOverlay(overlay, target, appendTo, calculateMinWidth = true) {\n  if (overlay && target) {\n    if (appendTo === \"self\") {\n      relativePosition(overlay, target);\n    } else {\n      if (calculateMinWidth) overlay.style.minWidth = getOuterWidth(target) + \"px\";\n      absolutePosition(overlay, target);\n    }\n  }\n}\n\n// src/dom/methods/getParentNode.ts\nfunction getParentNode(element) {\n  if (element) {\n    let parent = element.parentNode;\n    if (parent && parent instanceof ShadowRoot && parent.host) {\n      parent = parent.host;\n    }\n    return parent;\n  }\n  return null;\n}\n\n// src/dom/methods/isExist.ts\nfunction isExist(element) {\n  return !!(element !== null && typeof element !== \"undefined\" && element.nodeName && getParentNode(element));\n}\n\n// src/dom/methods/isElement.ts\nfunction isElement(element) {\n  return typeof HTMLElement !== \"undefined\" ? element instanceof HTMLElement : element !== null && typeof element === \"object\" && element.nodeType === 1 && typeof element.nodeName === \"string\";\n}\n\n// src/dom/methods/toElement.ts\nfunction toElement(element) {\n  let target = element;\n  if (element && typeof element === \"object\") {\n    if (Object.hasOwn(element, \"current\")) {\n      target = element.current;\n    } else if (Object.hasOwn(element, \"el\")) {\n      if (Object.hasOwn(element.el, \"nativeElement\")) {\n        target = element.el.nativeElement;\n      } else {\n        target = element.el;\n      }\n    }\n  }\n  return isElement(target) ? target : void 0;\n}\n\n// src/dom/methods/getTargetElement.ts\nfunction getTargetElement(target, currentElement) {\n  var _a;\n  if (!target) return void 0;\n  switch (target) {\n    case \"document\":\n      return document;\n    case \"window\":\n      return window;\n    case \"body\":\n      return document.body;\n    case \"@next\":\n      return currentElement == null ? void 0 : currentElement.nextElementSibling;\n    case \"@prev\":\n      return currentElement == null ? void 0 : currentElement.previousElementSibling;\n    case \"@parent\":\n      return currentElement == null ? void 0 : currentElement.parentElement;\n    case \"@grandparent\":\n      return (_a = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a.parentElement;\n    default:\n      {\n        if (typeof target === \"string\") {\n          return document.querySelector(target);\n        }\n        const isFunction = value => typeof value === \"function\" && \"call\" in value && \"apply\" in value;\n        const element = toElement(isFunction(target) ? target() : target);\n        return (element == null ? void 0 : element.nodeType) === 9 || isExist(element) ? element : void 0;\n      }\n  }\n}\n\n// src/dom/methods/appendChild.ts\nfunction appendChild(element, child) {\n  const target = getTargetElement(element, child);\n  if (target) target.appendChild(child);else throw new Error(\"Cannot append \" + child + \" to \" + element);\n}\n\n// src/dom/methods/calculateScrollbarHeight.ts\nvar calculatedScrollbarHeight = void 0;\nfunction calculateScrollbarHeight(element) {\n  if (element) {\n    const style = getComputedStyle(element);\n    return element.offsetHeight - element.clientHeight - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth);\n  } else {\n    if (calculatedScrollbarHeight != null) return calculatedScrollbarHeight;\n    const scrollDiv = document.createElement(\"div\");\n    addStyle(scrollDiv, {\n      width: \"100px\",\n      height: \"100px\",\n      overflow: \"scroll\",\n      position: \"absolute\",\n      top: \"-9999px\"\n    });\n    document.body.appendChild(scrollDiv);\n    const scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;\n    document.body.removeChild(scrollDiv);\n    calculatedScrollbarHeight = scrollbarHeight;\n    return scrollbarHeight;\n  }\n}\n\n// src/dom/methods/calculateScrollbarWidth.ts\nvar calculatedScrollbarWidth = void 0;\nfunction calculateScrollbarWidth(element) {\n  if (element) {\n    const style = getComputedStyle(element);\n    return element.offsetWidth - element.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);\n  } else {\n    if (calculatedScrollbarWidth != null) return calculatedScrollbarWidth;\n    const scrollDiv = document.createElement(\"div\");\n    addStyle(scrollDiv, {\n      width: \"100px\",\n      height: \"100px\",\n      overflow: \"scroll\",\n      position: \"absolute\",\n      top: \"-9999px\"\n    });\n    document.body.appendChild(scrollDiv);\n    const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    calculatedScrollbarWidth = scrollbarWidth;\n    return scrollbarWidth;\n  }\n}\n\n// src/dom/methods/clearSelection.ts\nfunction clearSelection() {\n  if (window.getSelection) {\n    const selection = window.getSelection() || {};\n    if (selection.empty) {\n      selection.empty();\n    } else if (selection.removeAllRanges && selection.rangeCount > 0 && selection.getRangeAt(0).getClientRects().length > 0) {\n      selection.removeAllRanges();\n    }\n  }\n}\n\n// src/dom/methods/setAttributes.ts\nfunction setAttributes(element, attributes = {}) {\n  if (isElement(element)) {\n    const computedStyles = (rule, value) => {\n      var _a, _b;\n      const styles = ((_a = element == null ? void 0 : element.$attrs) == null ? void 0 : _a[rule]) ? [(_b = element == null ? void 0 : element.$attrs) == null ? void 0 : _b[rule]] : [];\n      return [value].flat().reduce((cv, v) => {\n        if (v !== null && v !== void 0) {\n          const type = typeof v;\n          if (type === \"string\" || type === \"number\") {\n            cv.push(v);\n          } else if (type === \"object\") {\n            const _cv = Array.isArray(v) ? computedStyles(rule, v) : Object.entries(v).map(([_k, _v]) => rule === \"style\" && (!!_v || _v === 0) ? `${_k.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase()}:${_v}` : _v ? _k : void 0);\n            cv = _cv.length ? cv.concat(_cv.filter(c => !!c)) : cv;\n          }\n        }\n        return cv;\n      }, styles);\n    };\n    Object.entries(attributes).forEach(([key, value]) => {\n      if (value !== void 0 && value !== null) {\n        const matchedEvent = key.match(/^on(.+)/);\n        if (matchedEvent) {\n          element.addEventListener(matchedEvent[1].toLowerCase(), value);\n        } else if (key === \"p-bind\" || key === \"pBind\") {\n          setAttributes(element, value);\n        } else {\n          value = key === \"class\" ? [...new Set(computedStyles(\"class\", value))].join(\" \").trim() : key === \"style\" ? computedStyles(\"style\", value).join(\";\").trim() : value;\n          (element.$attrs = element.$attrs || {}) && (element.$attrs[key] = value);\n          element.setAttribute(key, value);\n        }\n      }\n    });\n  }\n}\n\n// src/dom/methods/createElement.ts\nfunction createElement(type, attributes = {}, ...children) {\n  if (type) {\n    const element = document.createElement(type);\n    setAttributes(element, attributes);\n    element.append(...children);\n    return element;\n  }\n  return void 0;\n}\n\n// src/dom/methods/createStyleMarkup.ts\nfunction createStyleMarkup(css, attributes = {}) {\n  return css ? `<style${Object.entries(attributes).reduce((s, [k, v]) => s + ` ${k}=\"${v}\"`, \"\")}>${css}</style>` : \"\";\n}\n\n// src/dom/methods/createStyleAsString.ts\nfunction createStyleAsString(css, options = {}) {\n  return createStyleMarkup(css, options);\n}\n\n// src/dom/methods/createStyleElement.ts\nfunction createStyleElement(css, attributes = {}, container) {\n  const element = createElement(\"style\", attributes, css);\n  container == null ? void 0 : container.appendChild(element);\n  return element;\n}\n\n// src/dom/methods/createStyleTag.ts\nfunction createStyleTag(attributes = {}, container) {\n  return createStyleElement(\"\", attributes, container || document.head);\n}\n\n// src/dom/methods/fadeIn.ts\nfunction fadeIn(element, duration) {\n  if (element) {\n    element.style.opacity = \"0\";\n    let last = + /* @__PURE__ */new Date();\n    let opacity = \"0\";\n    const tick = function () {\n      opacity = `${+element.style.opacity + ((/* @__PURE__ */new Date()).getTime() - last) / duration}`;\n      element.style.opacity = opacity;\n      last = + /* @__PURE__ */new Date();\n      if (+opacity < 1) {\n        if (\"requestAnimationFrame\" in window) requestAnimationFrame(tick);else setTimeout(tick, 16);\n      }\n    };\n    tick();\n  }\n}\n\n// src/dom/methods/fadeOut.ts\nfunction fadeOut(element, duration) {\n  if (element) {\n    let opacity = 1;\n    const interval = 50;\n    const gap = interval / duration;\n    const fading = setInterval(() => {\n      opacity -= gap;\n      if (opacity <= 0) {\n        opacity = 0;\n        clearInterval(fading);\n      }\n      element.style.opacity = opacity.toString();\n    }, interval);\n  }\n}\n\n// src/dom/methods/find.ts\nfunction find(element, selector) {\n  return isElement(element) ? Array.from(element.querySelectorAll(selector)) : [];\n}\n\n// src/dom/methods/findSingle.ts\nfunction findSingle(element, selector) {\n  return isElement(element) ? element.matches(selector) ? element : element.querySelector(selector) : null;\n}\n\n// src/dom/methods/focus.ts\nfunction focus(element, options) {\n  if (element && document.activeElement !== element) element.focus(options);\n}\n\n// src/dom/methods/getAttribute.ts\nfunction getAttribute(element, name) {\n  if (isElement(element)) {\n    const value = element.getAttribute(name);\n    if (!isNaN(value)) {\n      return +value;\n    }\n    if (value === \"true\" || value === \"false\") {\n      return value === \"true\";\n    }\n    return value;\n  }\n  return void 0;\n}\n\n// src/dom/methods/resolveUserAgent.ts\nfunction resolveUserAgent() {\n  const ua = navigator.userAgent.toLowerCase();\n  const match = /(chrome)[ ]([\\w.]+)/.exec(ua) || /(webkit)[ ]([\\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\\w.]+)/.exec(ua) || /(msie) ([\\w.]+)/.exec(ua) || ua.indexOf(\"compatible\") < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua) || [];\n  return {\n    browser: match[1] || \"\",\n    version: match[2] || \"0\"\n  };\n}\n\n// src/dom/methods/getBrowser.ts\nvar browser = null;\nfunction getBrowser() {\n  if (!browser) {\n    browser = {};\n    const matched = resolveUserAgent();\n    if (matched.browser) {\n      browser[matched.browser] = true;\n      browser[\"version\"] = matched.version;\n    }\n    if (browser[\"chrome\"]) {\n      browser[\"webkit\"] = true;\n    } else if (browser[\"webkit\"]) {\n      browser[\"safari\"] = true;\n    }\n  }\n  return browser;\n}\n\n// src/dom/methods/getBrowserLanguage.ts\nfunction getBrowserLanguage() {\n  return navigator.languages && navigator.languages.length && navigator.languages[0] || navigator.language || \"en\";\n}\n\n// src/dom/methods/getCSSProperty.ts\nfunction getCSSProperty(element, property, inline) {\n  var _a;\n  if (element && property) {\n    return inline ? (_a = element == null ? void 0 : element.style) == null ? void 0 : _a.getPropertyValue(property) : getComputedStyle(element).getPropertyValue(property);\n  }\n  return null;\n}\n\n// src/dom/methods/getCursorOffset.ts\nfunction getCursorOffset(element, prevText, nextText, currentText) {\n  if (element) {\n    const style = getComputedStyle(element);\n    const ghostDiv = document.createElement(\"div\");\n    ghostDiv.style.position = \"absolute\";\n    ghostDiv.style.top = \"0px\";\n    ghostDiv.style.left = \"0px\";\n    ghostDiv.style.visibility = \"hidden\";\n    ghostDiv.style.pointerEvents = \"none\";\n    ghostDiv.style.overflow = style.overflow;\n    ghostDiv.style.width = style.width;\n    ghostDiv.style.height = style.height;\n    ghostDiv.style.padding = style.padding;\n    ghostDiv.style.border = style.border;\n    ghostDiv.style.overflowWrap = style.overflowWrap;\n    ghostDiv.style.whiteSpace = style.whiteSpace;\n    ghostDiv.style.lineHeight = style.lineHeight;\n    ghostDiv.innerHTML = prevText.replace(/\\r\\n|\\r|\\n/g, \"<br />\");\n    const ghostSpan = document.createElement(\"span\");\n    ghostSpan.textContent = currentText;\n    ghostDiv.appendChild(ghostSpan);\n    const text = document.createTextNode(nextText);\n    ghostDiv.appendChild(text);\n    document.body.appendChild(ghostDiv);\n    const {\n      offsetLeft,\n      offsetTop,\n      clientHeight\n    } = ghostSpan;\n    document.body.removeChild(ghostDiv);\n    return {\n      left: Math.abs(offsetLeft - element.scrollLeft),\n      top: Math.abs(offsetTop - element.scrollTop) + clientHeight\n    };\n  }\n  return {\n    top: \"auto\",\n    left: \"auto\"\n  };\n}\n\n// src/dom/methods/getFocusableElements.ts\nfunction getFocusableElements(element, selector = \"\") {\n  const focusableElements = find(element, `button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`);\n  const visibleFocusableElements = [];\n  for (const focusableElement of focusableElements) {\n    if (getComputedStyle(focusableElement).display != \"none\" && getComputedStyle(focusableElement).visibility != \"hidden\") visibleFocusableElements.push(focusableElement);\n  }\n  return visibleFocusableElements;\n}\n\n// src/dom/methods/getFirstFocusableElement.ts\nfunction getFirstFocusableElement(element, selector) {\n  const focusableElements = getFocusableElements(element, selector);\n  return focusableElements.length > 0 ? focusableElements[0] : null;\n}\n\n// src/dom/methods/getHeight.ts\nfunction getHeight(element) {\n  if (element) {\n    let height = element.offsetHeight;\n    const style = getComputedStyle(element);\n    height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n    return height;\n  }\n  return 0;\n}\n\n// src/dom/methods/getHiddenElementOuterHeight.ts\nfunction getHiddenElementOuterHeight(element) {\n  if (element) {\n    element.style.visibility = \"hidden\";\n    element.style.display = \"block\";\n    const elementHeight = element.offsetHeight;\n    element.style.display = \"none\";\n    element.style.visibility = \"visible\";\n    return elementHeight;\n  }\n  return 0;\n}\n\n// src/dom/methods/getHiddenElementOuterWidth.ts\nfunction getHiddenElementOuterWidth(element) {\n  if (element) {\n    element.style.visibility = \"hidden\";\n    element.style.display = \"block\";\n    const elementWidth = element.offsetWidth;\n    element.style.display = \"none\";\n    element.style.visibility = \"visible\";\n    return elementWidth;\n  }\n  return 0;\n}\n\n// src/dom/methods/getIndex.ts\nfunction getIndex(element) {\n  var _a;\n  if (element) {\n    const children = (_a = getParentNode(element)) == null ? void 0 : _a.childNodes;\n    let num = 0;\n    if (children) {\n      for (let i = 0; i < children.length; i++) {\n        if (children[i] === element) return num;\n        if (children[i].nodeType === 1) num++;\n      }\n    }\n  }\n  return -1;\n}\n\n// src/dom/methods/getInnerWidth.ts\nfunction getInnerWidth(element) {\n  if (element) {\n    let width = element.offsetWidth;\n    const style = getComputedStyle(element);\n    width -= parseFloat(style.borderLeft) + parseFloat(style.borderRight);\n    return width;\n  }\n  return 0;\n}\n\n// src/dom/methods/getLastFocusableElement.ts\nfunction getLastFocusableElement(element, selector) {\n  const focusableElements = getFocusableElements(element, selector);\n  return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;\n}\n\n// src/dom/methods/getNextElementSibling.ts\nfunction getNextElementSibling(element, selector) {\n  let nextElement = element.nextElementSibling;\n  while (nextElement) {\n    if (nextElement.matches(selector)) {\n      return nextElement;\n    } else {\n      nextElement = nextElement.nextElementSibling;\n    }\n  }\n  return null;\n}\n\n// src/dom/methods/getNextFocusableElement.ts\nfunction getNextFocusableElement(container, element, selector) {\n  const focusableElements = getFocusableElements(container, selector);\n  const index = focusableElements.length > 0 ? focusableElements.findIndex(el => el === element) : -1;\n  const nextIndex = index > -1 && focusableElements.length >= index + 1 ? index + 1 : -1;\n  return nextIndex > -1 ? focusableElements[nextIndex] : null;\n}\n\n// src/dom/methods/getOffset.ts\nfunction getOffset(element) {\n  if (element) {\n    const rect = element.getBoundingClientRect();\n    return {\n      top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),\n      left: rect.left + (window.pageXOffset || getScrollLeft(document.documentElement) || getScrollLeft(document.body) || 0)\n    };\n  }\n  return {\n    top: \"auto\",\n    left: \"auto\"\n  };\n}\n\n// src/dom/methods/getOuterHeight.ts\nfunction getOuterHeight(element, margin) {\n  if (element) {\n    let height = element.offsetHeight;\n    if (margin) {\n      const style = getComputedStyle(element);\n      height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n    }\n    return height;\n  }\n  return 0;\n}\n\n// src/dom/methods/getParents.ts\nfunction getParents(element, parents = []) {\n  const parent = getParentNode(element);\n  return parent === null ? parents : getParents(parent, parents.concat([parent]));\n}\n\n// src/dom/methods/getPreviousElementSibling.ts\nfunction getPreviousElementSibling(element, selector) {\n  let previousElement = element.previousElementSibling;\n  while (previousElement) {\n    if (previousElement.matches(selector)) {\n      return previousElement;\n    } else {\n      previousElement = previousElement.previousElementSibling;\n    }\n  }\n  return null;\n}\n\n// src/dom/methods/getScrollableParents.ts\nfunction getScrollableParents(element) {\n  const scrollableParents = [];\n  if (element) {\n    const parents = getParents(element);\n    const overflowRegex = /(auto|scroll)/;\n    const overflowCheck = node => {\n      try {\n        const styleDeclaration = window[\"getComputedStyle\"](node, null);\n        return overflowRegex.test(styleDeclaration.getPropertyValue(\"overflow\")) || overflowRegex.test(styleDeclaration.getPropertyValue(\"overflowX\")) || overflowRegex.test(styleDeclaration.getPropertyValue(\"overflowY\"));\n      } catch (e) {\n        return false;\n      }\n    };\n    for (const parent of parents) {\n      const scrollSelectors = parent.nodeType === 1 && parent.dataset[\"scrollselectors\"];\n      if (scrollSelectors) {\n        const selectors = scrollSelectors.split(\",\");\n        for (const selector of selectors) {\n          const el = findSingle(parent, selector);\n          if (el && overflowCheck(el)) {\n            scrollableParents.push(el);\n          }\n        }\n      }\n      if (parent.nodeType !== 9 && overflowCheck(parent)) {\n        scrollableParents.push(parent);\n      }\n    }\n  }\n  return scrollableParents;\n}\n\n// src/dom/methods/getSelection.ts\nfunction getSelection() {\n  if (window.getSelection) return window.getSelection().toString();else if (document.getSelection) return document.getSelection().toString();\n  return void 0;\n}\n\n// src/dom/methods/getUserAgent.ts\nfunction getUserAgent() {\n  return navigator.userAgent;\n}\n\n// src/dom/methods/getWidth.ts\nfunction getWidth(element) {\n  if (element) {\n    let width = element.offsetWidth;\n    const style = getComputedStyle(element);\n    width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n    return width;\n  }\n  return 0;\n}\n\n// src/dom/methods/hasCSSAnimation.ts\nfunction hasCSSAnimation(element) {\n  if (element) {\n    const style = getComputedStyle(element);\n    const animationDuration = parseFloat(style.getPropertyValue(\"animation-duration\") || \"0\");\n    return animationDuration > 0;\n  }\n  return false;\n}\n\n// src/dom/methods/hasCSSTransition.ts\nfunction hasCSSTransition(element) {\n  if (element) {\n    const style = getComputedStyle(element);\n    const transitionDuration = parseFloat(style.getPropertyValue(\"transition-duration\") || \"0\");\n    return transitionDuration > 0;\n  }\n  return false;\n}\n\n// src/dom/methods/invokeElementMethod.ts\nfunction invokeElementMethod(element, methodName, args) {\n  const method = element[methodName];\n  if (typeof method === \"function\") {\n    method.apply(element, args != null ? args : []);\n  }\n}\n\n// src/dom/methods/isAndroid.ts\nfunction isAndroid() {\n  return /(android)/i.test(navigator.userAgent);\n}\n\n// src/dom/methods/isAttributeEquals.ts\nfunction isAttributeEquals(element, name, value) {\n  return isElement(element) ? getAttribute(element, name) === value : false;\n}\n\n// src/dom/methods/isAttributeNotEquals.ts\nfunction isAttributeNotEquals(element, name, value) {\n  return !isAttributeEquals(element, name, value);\n}\n\n// src/dom/methods/isClickable.ts\nfunction isClickable(element) {\n  if (element) {\n    const targetNode = element.nodeName;\n    const parentNode = element.parentElement && element.parentElement.nodeName;\n    return targetNode === \"INPUT\" || targetNode === \"TEXTAREA\" || targetNode === \"BUTTON\" || targetNode === \"A\" || parentNode === \"INPUT\" || parentNode === \"TEXTAREA\" || parentNode === \"BUTTON\" || parentNode === \"A\" || !!element.closest(\".p-button, .p-checkbox, .p-radiobutton\");\n  }\n  return false;\n}\n\n// src/dom/methods/isClient.ts\nfunction isClient() {\n  return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n}\n\n// src/dom/methods/isFocusableElement.ts\nfunction isFocusableElement(element, selector = \"\") {\n  return isElement(element) ? element.matches(`button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`) : false;\n}\n\n// src/dom/methods/isVisible.ts\nfunction isVisible(element) {\n  return !!(element && element.offsetParent != null);\n}\n\n// src/dom/methods/isHidden.ts\nfunction isHidden(element) {\n  return !isVisible(element);\n}\n\n// src/dom/methods/isIOS.ts\nfunction isIOS() {\n  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !(\"MSStream\" in window);\n}\n\n// src/dom/methods/isRTL.ts\nfunction isRTL(element) {\n  return element ? getComputedStyle(element).direction === \"rtl\" : false;\n}\n\n// src/dom/methods/isServer.ts\nfunction isServer() {\n  return !isClient();\n}\n\n// src/dom/methods/isTouchDevice.ts\nfunction isTouchDevice() {\n  return \"ontouchstart\" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;\n}\n\n// src/dom/methods/nestedPosition.ts\nfunction nestedPosition(element, level) {\n  var _a, _b;\n  if (element) {\n    const parentItem = element.parentElement;\n    const elementOffset = getOffset(parentItem);\n    const viewport = getViewport();\n    const sublistWidth = element.offsetParent ? element.offsetWidth : getHiddenElementOuterWidth(element);\n    const sublistHeight = element.offsetParent ? element.offsetHeight : getHiddenElementOuterHeight(element);\n    const itemOuterWidth = getOuterWidth((_a = parentItem == null ? void 0 : parentItem.children) == null ? void 0 : _a[0]);\n    const itemOuterHeight = getOuterHeight((_b = parentItem == null ? void 0 : parentItem.children) == null ? void 0 : _b[0]);\n    let left = \"\";\n    let top = \"\";\n    if (elementOffset.left + itemOuterWidth + sublistWidth > viewport.width - calculateScrollbarWidth()) {\n      if (elementOffset.left < sublistWidth) {\n        if (level % 2 === 1) {\n          left = elementOffset.left ? \"-\" + elementOffset.left + \"px\" : \"100%\";\n        } else if (level % 2 === 0) {\n          left = viewport.width - sublistWidth - calculateScrollbarWidth() + \"px\";\n        }\n      } else {\n        left = \"-100%\";\n      }\n    } else {\n      left = \"100%\";\n    }\n    if (element.getBoundingClientRect().top + itemOuterHeight + sublistHeight > viewport.height) {\n      top = `-${sublistHeight - itemOuterHeight}px`;\n    } else {\n      top = \"0px\";\n    }\n    element.style.top = top;\n    element.style.insetInlineStart = left;\n  }\n}\n\n// src/dom/methods/remove.ts\nfunction remove(element) {\n  var _a;\n  if (element) {\n    if (!(\"remove\" in Element.prototype)) (_a = element.parentNode) == null ? void 0 : _a.removeChild(element);else element.remove();\n  }\n}\n\n// src/dom/methods/removeChild.ts\nfunction removeChild(element, child) {\n  const target = toElement(element);\n  if (target) target.removeChild(child);else throw new Error(\"Cannot remove \" + child + \" from \" + element);\n}\n\n// src/dom/methods/removeStyleTag.ts\nfunction removeStyleTag(element) {\n  var _a;\n  if (isExist(element)) {\n    try {\n      (_a = element.parentNode) == null ? void 0 : _a.removeChild(element);\n    } catch (e) {}\n    return null;\n  }\n  return element;\n}\n\n// src/dom/methods/scrollInView.ts\nfunction scrollInView(container, item) {\n  const borderTopValue = getComputedStyle(container).getPropertyValue(\"borderTopWidth\");\n  const borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;\n  const paddingTopValue = getComputedStyle(container).getPropertyValue(\"paddingTop\");\n  const paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;\n  const containerRect = container.getBoundingClientRect();\n  const itemRect = item.getBoundingClientRect();\n  const offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;\n  const scroll = container.scrollTop;\n  const elementHeight = container.clientHeight;\n  const itemHeight = getOuterHeight(item);\n  if (offset < 0) {\n    container.scrollTop = scroll + offset;\n  } else if (offset + itemHeight > elementHeight) {\n    container.scrollTop = scroll + offset - elementHeight + itemHeight;\n  }\n}\n\n// src/dom/methods/setAttribute.ts\nfunction setAttribute(element, attribute = \"\", value) {\n  if (isElement(element) && value !== null && value !== void 0) {\n    element.setAttribute(attribute, value);\n  }\n}\n\n// src/dom/methods/setCSSProperty.ts\nfunction setCSSProperty(element, property, value = null, priority) {\n  var _a;\n  property && ((_a = element == null ? void 0 : element.style) == null ? void 0 : _a.setProperty(property, value, priority));\n}\nexport { absolutePosition, addClass, addStyle, alignOverlay, appendChild, blockBodyScroll, calculateBodyScrollbarWidth, calculateScrollbarHeight, calculateScrollbarWidth, clearSelection, createElement, createStyleAsString, createStyleElement, createStyleMarkup, createStyleTag, exportCSV, fadeIn, fadeOut, find, findSingle, focus, getAttribute, getBrowser, getBrowserLanguage, getCSSProperty, getCSSVariableByRegex, getCursorOffset, getFirstFocusableElement, getFocusableElements, getHeight, getHiddenElementDimensions, getHiddenElementOuterHeight, getHiddenElementOuterWidth, getIndex, getInnerWidth, getLastFocusableElement, getNextElementSibling, getNextFocusableElement, getOffset, getOuterHeight, getOuterWidth, getParentNode, getParents, getPreviousElementSibling, getScrollLeft, getScrollableParents, getSelection, getTargetElement, getUserAgent, getViewport, getWidth, getWindowScrollLeft, getWindowScrollTop, hasCSSAnimation, hasCSSTransition, hasClass, invokeElementMethod, isAndroid, isAttributeEquals, isAttributeNotEquals, isClickable, isClient, isElement, isExist, isFocusableElement, isHidden, isIOS, isRTL, isServer, isTouchDevice, isVisible, nestedPosition, relativePosition, remove, removeChild, removeClass, removeStyleTag, resolveUserAgent, saveAs, scrollInView, setAttribute, setAttributes, setCSSProperty, toElement, unblockBodyScroll };","map":{"version":3,"names":["hasClass","element","className","classList","contains","RegExp","test","addClass","fn","_className","add","flat","filter","Boolean","forEach","_classNames","split","calculateBodyScrollbarWidth","window","innerWidth","document","documentElement","offsetWidth","blockBodyScroll","option","body","variableName","style","setProperty","saveAs","file","link","createElement","download","name","src","setAttribute","display","appendChild","click","removeChild","exportCSV","csv","filename","blob","Blob","type","navigator","msSaveOrOpenBlob","isDownloaded","URL","createObjectURL","open","encodeURI","removeClass","remove","replace","join","unblockBodyScroll","removeProperty","getCSSVariableByRegex","variableRegex","sheet","styleSheets","rule","cssRules","property","value","getPropertyValue","trim","e","getHiddenElementDimensions","dimensions","width","height","visibility","offsetHeight","getViewport","win","d","g","getElementsByTagName","w","clientWidth","h","innerHeight","clientHeight","getScrollLeft","Math","abs","scrollLeft","getWindowScrollLeft","doc","pageXOffset","clientLeft","getWindowScrollTop","pageYOffset","scrollTop","clientTop","absolutePosition","target","gutter","_a","_b","_c","_d","elementDimensions","offsetParent","elementOuterHeight","elementOuterWidth","targetOuterHeight","targetOuterWidth","targetOffset","getBoundingClientRect","windowScrollTop","windowScrollLeft","viewport","top","left","origin","max","insetInlineStart","transformOrigin","marginTop","addStyle","cssText","Object","entries","key","getOuterWidth","margin","HTMLElement","getComputedStyle","parseFloat","marginLeft","marginRight","relativePosition","targetHeight","alignOverlay","overlay","appendTo","calculateMinWidth","minWidth","getParentNode","parent","parentNode","ShadowRoot","host","isExist","nodeName","isElement","nodeType","toElement","hasOwn","current","el","nativeElement","getTargetElement","currentElement","nextElementSibling","previousElementSibling","parentElement","querySelector","isFunction","child","Error","calculatedScrollbarHeight","calculateScrollbarHeight","borderTopWidth","borderBottomWidth","scrollDiv","overflow","position","scrollbarHeight","calculatedScrollbarWidth","calculateScrollbarWidth","borderLeftWidth","borderRightWidth","scrollbarWidth","clearSelection","getSelection","selection","empty","removeAllRanges","rangeCount","getRangeAt","getClientRects","length","setAttributes","attributes","computedStyles","styles","$attrs","reduce","cv","v","push","_cv","Array","isArray","map","_k","_v","toLowerCase","concat","c","matchedEvent","match","addEventListener","Set","children","append","createStyleMarkup","css","s","k","createStyleAsString","options","createStyleElement","container","createStyleTag","head","fadeIn","duration","opacity","last","Date","tick","getTime","requestAnimationFrame","setTimeout","fadeOut","interval","gap","fading","setInterval","clearInterval","toString","find","selector","from","querySelectorAll","findSingle","matches","focus","activeElement","getAttribute","isNaN","resolveUserAgent","ua","userAgent","exec","indexOf","browser","version","getBrowser","matched","getBrowserLanguage","languages","language","getCSSProperty","inline","getCursorOffset","prevText","nextText","currentText","ghostDiv","pointerEvents","padding","border","overflowWrap","whiteSpace","lineHeight","innerHTML","ghostSpan","textContent","text","createTextNode","offsetLeft","offsetTop","getFocusableElements","focusableElements","visibleFocusableElements","focusableElement","getFirstFocusableElement","getHeight","paddingTop","paddingBottom","getHiddenElementOuterHeight","elementHeight","getHiddenElementOuterWidth","elementWidth","getIndex","childNodes","num","i","getInnerWidth","borderLeft","borderRight","getLastFocusableElement","getNextElementSibling","nextElement","getNextFocusableElement","index","findIndex","nextIndex","getOffset","rect","getOuterHeight","marginBottom","getParents","parents","getPreviousElementSibling","previousElement","getScrollableParents","scrollableParents","overflowRegex","overflowCheck","node","styleDeclaration","scrollSelectors","dataset","selectors","getUserAgent","getWidth","paddingLeft","paddingRight","hasCSSAnimation","animationDuration","hasCSSTransition","transitionDuration","invokeElementMethod","methodName","args","method","apply","isAndroid","isAttributeEquals","isAttributeNotEquals","isClickable","targetNode","closest","isClient","isFocusableElement","isVisible","isHidden","isIOS","isRTL","direction","isServer","isTouchDevice","maxTouchPoints","msMaxTouchPoints","nestedPosition","level","parentItem","elementOffset","sublistWidth","sublistHeight","itemOuterWidth","itemOuterHeight","Element","prototype","removeStyleTag","scrollInView","item","borderTopValue","borderTop","paddingTopValue","containerRect","itemRect","offset","scroll","itemHeight","attribute","setCSSProperty","priority"],"sources":["../../src/dom/methods/hasClass.ts","../../src/dom/methods/addClass.ts","../../src/dom/methods/calculateBodyScrollbarWidth.ts","../../src/dom/helpers/blockBodyScroll.ts","../../src/dom/helpers/saveAs.ts","../../src/dom/helpers/exportCSV.ts","../../src/dom/methods/removeClass.ts","../../src/dom/helpers/unblockBodyScroll.ts","../../src/dom/methods/getCSSVariableByRegex.ts","../../src/dom/methods/getHiddenElementDimensions.ts","../../src/dom/methods/getViewport.ts","../../src/dom/methods/getScrollLeft.ts","../../src/dom/methods/getWindowScrollLeft.ts","../../src/dom/methods/getWindowScrollTop.ts","../../src/dom/methods/absolutePosition.ts","../../src/dom/methods/addStyle.ts","../../src/dom/methods/getOuterWidth.ts","../../src/dom/methods/relativePosition.ts","../../src/dom/methods/alignOverlay.ts","../../src/dom/methods/getParentNode.ts","../../src/dom/methods/isExist.ts","../../src/dom/methods/isElement.ts","../../src/dom/methods/toElement.ts","../../src/dom/methods/getTargetElement.ts","../../src/dom/methods/appendChild.ts","../../src/dom/methods/calculateScrollbarHeight.ts","../../src/dom/methods/calculateScrollbarWidth.ts","../../src/dom/methods/clearSelection.ts","../../src/dom/methods/setAttributes.ts","../../src/dom/methods/createElement.ts","../../src/dom/methods/createStyleMarkup.ts","../../src/dom/methods/createStyleAsString.ts","../../src/dom/methods/createStyleElement.ts","../../src/dom/methods/createStyleTag.ts","../../src/dom/methods/fadeIn.ts","../../src/dom/methods/fadeOut.ts","../../src/dom/methods/find.ts","../../src/dom/methods/findSingle.ts","../../src/dom/methods/focus.ts","../../src/dom/methods/getAttribute.ts","../../src/dom/methods/resolveUserAgent.ts","../../src/dom/methods/getBrowser.ts","../../src/dom/methods/getBrowserLanguage.ts","../../src/dom/methods/getCSSProperty.ts","../../src/dom/methods/getCursorOffset.ts","../../src/dom/methods/getFocusableElements.ts","../../src/dom/methods/getFirstFocusableElement.ts","../../src/dom/methods/getHeight.ts","../../src/dom/methods/getHiddenElementOuterHeight.ts","../../src/dom/methods/getHiddenElementOuterWidth.ts","../../src/dom/methods/getIndex.ts","../../src/dom/methods/getInnerWidth.ts","../../src/dom/methods/getLastFocusableElement.ts","../../src/dom/methods/getNextElementSibling.ts","../../src/dom/methods/getNextFocusableElement.ts","../../src/dom/methods/getOffset.ts","../../src/dom/methods/getOuterHeight.ts","../../src/dom/methods/getParents.ts","../../src/dom/methods/getPreviousElementSibling.ts","../../src/dom/methods/getScrollableParents.ts","../../src/dom/methods/getSelection.ts","../../src/dom/methods/getUserAgent.ts","../../src/dom/methods/getWidth.ts","../../src/dom/methods/hasCSSAnimation.ts","../../src/dom/methods/hasCSSTransition.ts","../../src/dom/methods/invokeElementMethod.ts","../../src/dom/methods/isAndroid.ts","../../src/dom/methods/isAttributeEquals.ts","../../src/dom/methods/isAttributeNotEquals.ts","../../src/dom/methods/isClickable.ts","../../src/dom/methods/isClient.ts","../../src/dom/methods/isFocusableElement.ts","../../src/dom/methods/isVisible.ts","../../src/dom/methods/isHidden.ts","../../src/dom/methods/isIOS.ts","../../src/dom/methods/isRTL.ts","../../src/dom/methods/isServer.ts","../../src/dom/methods/isTouchDevice.ts","../../src/dom/methods/nestedPosition.ts","../../src/dom/methods/remove.ts","../../src/dom/methods/removeChild.ts","../../src/dom/methods/removeStyleTag.ts","../../src/dom/methods/scrollInView.ts","../../src/dom/methods/setAttribute.ts","../../src/dom/methods/setCSSProperty.ts"],"sourcesContent":["export default function hasClass(element: Element, className: string): boolean {\n    if (element) {\n        if (element.classList) return element.classList.contains(className);\n        else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n    }\n\n    return false;\n}\n","import hasClass from './hasClass';\n\nexport default function addClass(element: Element, className: string | string[]): void {\n    if (element && className) {\n        const fn = (_className: string) => {\n            if (!hasClass(element, _className)) {\n                if (element.classList) element.classList.add(_className);\n                else element.className += ' ' + _className;\n            }\n        };\n\n        [className]\n            .flat()\n            .filter(Boolean)\n            .forEach((_classNames) => _classNames.split(' ').forEach(fn));\n    }\n}\n","export default function calculateBodyScrollbarWidth(): number {\n    return window.innerWidth - document.documentElement.offsetWidth;\n}\n","import addClass from '../methods/addClass';\nimport calculateBodyScrollbarWidth from '../methods/calculateBodyScrollbarWidth';\n\nexport interface BlockBodyScrollOptions {\n    className?: string;\n    variableName?: string;\n}\n\nexport default function blockBodyScroll(option: string | BlockBodyScrollOptions | undefined): void {\n    if (typeof option === 'string') {\n        addClass(document.body, option || 'p-overflow-hidden');\n    } else {\n        option?.variableName && document.body.style.setProperty(option.variableName, calculateBodyScrollbarWidth() + 'px');\n        addClass(document.body, option?.className || 'p-overflow-hidden');\n    }\n}\n","export default function saveAs(file: { name: string; src: string }): boolean {\n    if (file) {\n        const link = document.createElement('a');\n\n        if (link.download !== undefined) {\n            const { name, src } = file;\n\n            link.setAttribute('href', src);\n            link.setAttribute('download', name);\n            link.style.display = 'none';\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n\n            return true;\n        }\n    }\n\n    return false;\n}\n","import saveAs from './saveAs';\n\nexport default function exportCSV(csv: any, filename: string): void {\n    const blob = new Blob([csv], {\n        type: 'application/csv;charset=utf-8;'\n    });\n\n    if ((window.navigator as any).msSaveOrOpenBlob) {\n        (navigator as any).msSaveOrOpenBlob(blob, filename + '.csv');\n    } else {\n        const isDownloaded = saveAs({ name: filename + '.csv', src: URL.createObjectURL(blob) });\n\n        if (!isDownloaded) {\n            csv = 'data:text/csv;charset=utf-8,' + csv;\n            window.open(encodeURI(csv));\n        }\n    }\n}\n","export default function removeClass(element: Element, className: string | string[]): void {\n    if (element && className) {\n        const fn = (_className: string) => {\n            if (element.classList) element.classList.remove(_className);\n            else element.className = element.className.replace(new RegExp('(^|\\\\b)' + _className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        };\n\n        [className]\n            .flat()\n            .filter(Boolean)\n            .forEach((_classNames) => _classNames.split(' ').forEach(fn));\n    }\n}\n","import removeClass from '../methods/removeClass';\n\nexport interface UnblockBodyScrollOptions {\n    className?: string;\n    variableName?: string;\n}\n\nexport default function unblockBodyScroll(option: string | UnblockBodyScrollOptions | undefined): void {\n    if (typeof option === 'string') {\n        removeClass(document.body, option || 'p-overflow-hidden');\n    } else {\n        if (option?.variableName) document.body.style.removeProperty(option.variableName);\n        removeClass(document.body, option?.className || 'p-overflow-hidden');\n    }\n}\n","export default function getCSSVariableByRegex(variableRegex: RegExp): { name: string | undefined; value: string | undefined } | null {\n    for (const sheet of document?.styleSheets) {\n        try {\n            for (const rule of sheet?.cssRules) {\n                for (const property of (rule as CSSStyleRule)?.style) {\n                    if (variableRegex.test(property)) {\n                        return { name: property, value: (rule as CSSStyleRule).style.getPropertyValue(property).trim() };\n                    }\n                }\n            }\n        } catch {}\n    }\n\n    return null;\n}\n","export default function getHiddenElementDimensions(element?: HTMLElement): { width: number; height: number } {\n    const dimensions: { width: number; height: number } = { width: 0, height: 0 };\n\n    if (element) {\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        dimensions.width = element.offsetWidth;\n        dimensions.height = element.offsetHeight;\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n    }\n\n    return dimensions;\n}\n","export default function getViewport(): { width: number; height: number } {\n    const win = window,\n        d = document,\n        e = d.documentElement,\n        g = d.getElementsByTagName('body')[0],\n        w = win.innerWidth || e.clientWidth || g.clientWidth,\n        h = win.innerHeight || e.clientHeight || g.clientHeight;\n\n    return { width: w, height: h };\n}\n","export default function getScrollLeft(element?: HTMLElement): number {\n    // for RTL scrollLeft should be negative\n    return element ? Math.abs(element.scrollLeft) : 0;\n}\n","import getScrollLeft from './getScrollLeft';\n\nexport default function getWindowScrollLeft(): number {\n    const doc = document.documentElement;\n\n    return (window.pageXOffset || getScrollLeft(doc)) - (doc.clientLeft || 0);\n}\n","export default function getWindowScrollTop(): number {\n    const doc = document.documentElement;\n\n    return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n}\n","import getCSSVariableByRegex from './getCSSVariableByRegex';\nimport getHiddenElementDimensions from './getHiddenElementDimensions';\nimport getViewport from './getViewport';\nimport getWindowScrollLeft from './getWindowScrollLeft';\nimport getWindowScrollTop from './getWindowScrollTop';\n\nexport default function absolutePosition(element: HTMLElement, target: HTMLElement, gutter: boolean = true): void {\n    if (element) {\n        const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);\n        const elementOuterHeight = elementDimensions.height;\n        const elementOuterWidth = elementDimensions.width;\n        const targetOuterHeight = target.offsetHeight;\n        const targetOuterWidth = target.offsetWidth;\n        const targetOffset = target.getBoundingClientRect();\n        const windowScrollTop = getWindowScrollTop();\n        const windowScrollLeft = getWindowScrollLeft();\n        const viewport = getViewport();\n        let top,\n            left,\n            origin = 'top';\n\n        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {\n            top = targetOffset.top + windowScrollTop - elementOuterHeight;\n            origin = 'bottom';\n\n            if (top < 0) {\n                top = windowScrollTop;\n            }\n        } else {\n            top = targetOuterHeight + targetOffset.top + windowScrollTop;\n        }\n\n        if (targetOffset.left + elementOuterWidth > viewport.width) left = Math.max(0, targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth);\n        else left = targetOffset.left + windowScrollLeft;\n\n        element.style.top = top + 'px';\n        element.style.insetInlineStart = left + 'px';\n        element.style.transformOrigin = origin;\n        if (gutter) element.style.marginTop = origin === 'bottom' ? `calc(${getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? '2px'} * -1)` : (getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? '');\n    }\n}\n","export default function addStyle(element: HTMLElement, style: string | object): void {\n    if (element) {\n        if (typeof style === 'string') {\n            element.style.cssText = style;\n        } else {\n            Object.entries(style || {}).forEach(([key, value]: [string, string]) => ((element.style as any)[key] = value));\n        }\n    }\n}\n","export default function getOuterWidth(element: unknown, margin?: boolean): number {\n    if (element instanceof HTMLElement) {\n        let width = element.offsetWidth;\n\n        if (margin) {\n            const style = getComputedStyle(element);\n\n            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);\n        }\n\n        return width;\n    }\n\n    return 0;\n}\n","import getCSSVariableByRegex from './getCSSVariableByRegex';\nimport getHiddenElementDimensions from './getHiddenElementDimensions';\nimport getViewport from './getViewport';\n\nexport default function relativePosition(element: HTMLElement, target: HTMLElement, gutter: boolean = true): void {\n    if (element) {\n        const elementDimensions = element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } : getHiddenElementDimensions(element);\n        const targetHeight = target.offsetHeight;\n        const targetOffset = target.getBoundingClientRect();\n        const viewport = getViewport();\n        let top,\n            left,\n            origin = 'top';\n\n        if (targetOffset.top + targetHeight + elementDimensions.height > viewport.height) {\n            top = -1 * elementDimensions.height;\n            origin = 'bottom';\n\n            if (targetOffset.top + top < 0) {\n                top = -1 * targetOffset.top;\n            }\n        } else {\n            top = targetHeight;\n        }\n\n        if (elementDimensions.width > viewport.width) {\n            // element wider then viewport and cannot fit on screen (align at left side of viewport)\n            left = targetOffset.left * -1;\n        } else if (targetOffset.left + elementDimensions.width > viewport.width) {\n            // element wider then viewport but can be fit on screen (align at right side of viewport)\n            left = (targetOffset.left + elementDimensions.width - viewport.width) * -1;\n        } else {\n            // element fits on screen (align with target)\n            left = 0;\n        }\n\n        element.style.top = top + 'px';\n        element.style.insetInlineStart = left + 'px';\n        element.style.transformOrigin = origin;\n        gutter && (element.style.marginTop = origin === 'bottom' ? `calc(${getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? '2px'} * -1)` : (getCSSVariableByRegex(/-anchor-gutter$/)?.value ?? ''));\n    }\n}\n","import absolutePosition from './absolutePosition';\nimport getOuterWidth from './getOuterWidth';\nimport relativePosition from './relativePosition';\n\nexport default function alignOverlay(overlay: HTMLElement, target: HTMLElement, appendTo: string, calculateMinWidth: boolean = true) {\n    if (overlay && target) {\n        if (appendTo === 'self') {\n            relativePosition(overlay, target);\n        } else {\n            if (calculateMinWidth) overlay.style.minWidth = getOuterWidth(target) + 'px';\n            absolutePosition(overlay, target);\n        }\n    }\n}\n","export default function getParentNode(element: Node): ParentNode | null {\n    if (element) {\n        let parent = element.parentNode;\n\n        if (parent && parent instanceof ShadowRoot && parent.host) {\n            parent = parent.host;\n        }\n\n        return parent;\n    }\n\n    return null;\n}\n","import getParentNode from './getParentNode';\n\nexport default function isExist(element: Node): boolean {\n    return !!(element !== null && typeof element !== 'undefined' && element.nodeName && getParentNode(element));\n}\n","export default function isElement(element: unknown): element is Element {\n    return typeof HTMLElement !== 'undefined' ? element instanceof HTMLElement : element !== null && typeof element === 'object' && (element as Element).nodeType === 1 && typeof (element as Element).nodeName === 'string';\n}\n","import isElement from './isElement';\n\ntype ReactElement = { current: Element | null | undefined };\ntype VueElement = { el: Element | null | undefined };\ntype AngularElement = { el: { nativeElement: Element | undefined } };\n\nexport default function toElement(element: unknown): Element | null | undefined {\n    let target = element;\n\n    if (element && typeof element === 'object') {\n        if (Object.hasOwn(element, 'current')) {\n            // For React\n            target = (element as ReactElement).current;\n        } else if (Object.hasOwn(element, 'el')) {\n            if (Object.hasOwn((element as AngularElement).el, 'nativeElement')) {\n                // For Angular\n                target = (element as AngularElement).el.nativeElement;\n            } else {\n                // For Vue\n                target = (element as VueElement).el;\n            }\n        }\n    }\n\n    return isElement(target) ? target : undefined;\n}\n","import isExist from './isExist';\nimport toElement from './toElement';\n\nexport default function getTargetElement(target: unknown, currentElement: Element): Window | Document | Element | null | undefined {\n    if (!target) return undefined;\n\n    switch (target) {\n        case 'document':\n            return document;\n        case 'window':\n            return window;\n        case 'body':\n            return document.body;\n        case '@next':\n            return currentElement?.nextElementSibling;\n        case '@prev':\n            return currentElement?.previousElementSibling;\n        case '@parent':\n            return currentElement?.parentElement;\n        case '@grandparent':\n            return currentElement?.parentElement?.parentElement;\n\n        default: {\n            if (typeof target === 'string') {\n                return document.querySelector(target);\n            }\n\n            const isFunction = (value: unknown): value is (...args: unknown[]) => unknown => typeof value === 'function' && 'call' in value && 'apply' in value;\n            const element = toElement(isFunction(target) ? target() : target);\n\n            return element?.nodeType === 9 || isExist(element as Element) ? element : undefined;\n        }\n    }\n}\n","import getTargetElement from './getTargetElement';\n\nexport default function appendChild(element: unknown, child: Node | Element) {\n    const target: Document | Element | null | undefined = getTargetElement(element, child as Element) as Exclude<ReturnType<typeof getTargetElement>, Window>;\n\n    if (target) target.appendChild(child);\n    else throw new Error('Cannot append ' + child + ' to ' + element);\n}\n","import addStyle from './addStyle';\n\nlet calculatedScrollbarHeight: number | undefined = undefined;\n\nexport default function calculateScrollbarHeight(element?: HTMLElement): number {\n    if (element) {\n        const style = getComputedStyle(element);\n\n        return element.offsetHeight - element.clientHeight - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth);\n    } else {\n        if (calculatedScrollbarHeight != null) return calculatedScrollbarHeight;\n\n        const scrollDiv = document.createElement('div');\n\n        addStyle(scrollDiv, {\n            width: '100px',\n            height: '100px',\n            overflow: 'scroll',\n            position: 'absolute',\n            top: '-9999px'\n        });\n        document.body.appendChild(scrollDiv);\n\n        const scrollbarHeight = scrollDiv.offsetHeight - scrollDiv.clientHeight;\n\n        document.body.removeChild(scrollDiv);\n\n        calculatedScrollbarHeight = scrollbarHeight;\n\n        return scrollbarHeight;\n    }\n}\n","import addStyle from './addStyle';\n\nlet calculatedScrollbarWidth: number | undefined = undefined;\n\nexport default function calculateScrollbarWidth(element?: HTMLElement): number {\n    if (element) {\n        const style = getComputedStyle(element);\n\n        return element.offsetWidth - element.clientWidth - parseFloat(style.borderLeftWidth) - parseFloat(style.borderRightWidth);\n    } else {\n        if (calculatedScrollbarWidth != null) return calculatedScrollbarWidth;\n\n        const scrollDiv = document.createElement('div');\n\n        addStyle(scrollDiv, {\n            width: '100px',\n            height: '100px',\n            overflow: 'scroll',\n            position: 'absolute',\n            top: '-9999px'\n        });\n        document.body.appendChild(scrollDiv);\n\n        const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n\n        document.body.removeChild(scrollDiv);\n\n        calculatedScrollbarWidth = scrollbarWidth;\n\n        return scrollbarWidth;\n    }\n}\n","export default function clearSelection(): void {\n    if (window.getSelection) {\n        const selection: any = window.getSelection() || {};\n\n        if (selection.empty) {\n            selection.empty();\n        } else if (selection.removeAllRanges && selection.rangeCount > 0 && selection.getRangeAt(0).getClientRects().length > 0) {\n            selection.removeAllRanges();\n        }\n    }\n}\n","import isElement from './isElement';\n\nexport default function setAttributes(element: HTMLElement, attributes: { [key: string]: any } = {}): void {\n    if (isElement(element)) {\n        const computedStyles = (rule: string, value: any): string[] => {\n            const styles = (element as any)?.$attrs?.[rule] ? [(element as any)?.$attrs?.[rule]] : [];\n\n            return [value].flat().reduce((cv, v) => {\n                if (v !== null && v !== undefined) {\n                    const type = typeof v;\n\n                    if (type === 'string' || type === 'number') {\n                        cv.push(v);\n                    } else if (type === 'object') {\n                        const _cv = Array.isArray(v) ? computedStyles(rule, v) : Object.entries(v).map(([_k, _v]) => (rule === 'style' && (!!_v || _v === 0) ? `${_k.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()}:${_v}` : _v ? _k : undefined));\n\n                        cv = _cv.length ? cv.concat(_cv.filter((c) => !!c)) : cv;\n                    }\n                }\n\n                return cv;\n            }, styles);\n        };\n\n        Object.entries(attributes).forEach(([key, value]) => {\n            if (value !== undefined && value !== null) {\n                const matchedEvent = key.match(/^on(.+)/);\n\n                if (matchedEvent) {\n                    element.addEventListener(matchedEvent[1].toLowerCase(), value);\n                } else if (key === 'p-bind' || key === 'pBind') {\n                    setAttributes(element, value);\n                } else {\n                    value = key === 'class' ? [...new Set(computedStyles('class', value))].join(' ').trim() : key === 'style' ? computedStyles('style', value).join(';').trim() : value;\n                    ((element as any).$attrs = (element as any).$attrs || {}) && ((element as any).$attrs[key] = value);\n                    element.setAttribute(key, value);\n                }\n            }\n        });\n    }\n}\n","import setAttributes from './setAttributes';\n\nexport default function createElement(type: string, attributes: Record<string, unknown> = {}, ...children: (string | Node)[]): HTMLElement | undefined {\n    if (type) {\n        const element = document.createElement(type);\n\n        setAttributes(element, attributes);\n        element.append(...children);\n\n        return element;\n    }\n\n    return undefined;\n}\n","export default function createStyleMarkup(css?: string, attributes: Record<string, unknown> = {}): string {\n    return css ? `<style${Object.entries(attributes).reduce((s, [k, v]) => s + ` ${k}=\"${v}\"`, '')}>${css}</style>` : '';\n}\n","import createStyleMarkup from './createStyleMarkup';\n\n/**\n * @deprecated Use `createStyleMarkup` instead.\n */\nexport default function createStyleAsString(css?: string, options: Record<string, unknown> = {}) {\n    return createStyleMarkup(css, options);\n}\n","import createElement from './createElement';\n\nexport default function createStyleElement(css: string, attributes: Record<string, unknown> = {}, container?: Element): HTMLStyleElement {\n    const element = createElement('style', attributes, css)! as HTMLStyleElement;\n\n    container?.appendChild(element);\n\n    return element;\n}\n","import createStyleElement from './createStyleElement';\n\n/**\n * @deprecated Use `createStyleElement` instead.\n */\nexport default function createStyleTag(attributes: Record<string, unknown> = {}, container?: Element): HTMLStyleElement {\n    return createStyleElement('', attributes, container || document.head);\n}\n","export default function fadeIn(element: HTMLElement, duration: number): void {\n    if (element) {\n        element.style.opacity = '0';\n\n        let last = +new Date();\n        let opacity = '0';\n\n        const tick = function () {\n            opacity = `${+element.style.opacity + (new Date().getTime() - last) / duration}`;\n            element.style.opacity = opacity;\n            last = +new Date();\n\n            if (+opacity < 1) {\n                if ('requestAnimationFrame' in window) requestAnimationFrame(tick);\n                else setTimeout(tick, 16);\n            }\n        };\n\n        tick();\n    }\n}\n","export default function fadeOut(element: HTMLElement, duration: number): void {\n    if (element) {\n        let opacity = 1;\n        const interval = 50;\n        const gap = interval / duration;\n\n        const fading = setInterval(() => {\n            opacity -= gap;\n\n            if (opacity <= 0) {\n                opacity = 0;\n                clearInterval(fading);\n            }\n\n            element.style.opacity = opacity.toString();\n        }, interval);\n    }\n}\n","import isElement from './isElement';\n\nexport default function find(element: Element, selector: string): Element[] {\n    return isElement(element) ? Array.from(element.querySelectorAll(selector)) : [];\n}\n","import isElement from './isElement';\n\nexport default function findSingle(element: Element, selector: string): Element | null {\n    return isElement(element) ? (element.matches(selector) ? element : element.querySelector(selector)) : null;\n}\n","export default function focus(element: HTMLElement, options?: FocusOptions): void {\n    if (element && document.activeElement !== element) element.focus(options);\n}\n","import isElement from './isElement';\n\nexport default function getAttribute(element: Element, name: string): any {\n    if (isElement(element)) {\n        const value = element.getAttribute(name);\n\n        if (!isNaN(value as any)) {\n            return +(value as string);\n        }\n\n        if (value === 'true' || value === 'false') {\n            return value === 'true';\n        }\n\n        return value;\n    }\n\n    return undefined;\n}\n","export default function resolveUserAgent(): { browser: string | undefined; version: string | undefined } {\n    const ua = navigator.userAgent.toLowerCase();\n    const match = /(chrome)[ ]([\\w.]+)/.exec(ua) || /(webkit)[ ]([\\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ ]([\\w.]+)/.exec(ua) || /(msie) ([\\w.]+)/.exec(ua) || (ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\\w.]+)|)/.exec(ua)) || [];\n\n    return {\n        browser: match[1] || '',\n        version: match[2] || '0'\n    };\n}\n","import resolveUserAgent from './resolveUserAgent';\n\ntype BrowserType = {\n    [key: string]: string | boolean | undefined;\n};\n\nlet browser: BrowserType | null = null;\n\nexport default function getBrowser(): BrowserType {\n    if (!browser) {\n        browser = {};\n\n        const matched = resolveUserAgent();\n\n        if (matched.browser) {\n            browser[matched.browser] = true;\n            browser['version'] = matched.version;\n        }\n\n        if (browser['chrome']) {\n            browser['webkit'] = true;\n        } else if (browser['webkit']) {\n            browser['safari'] = true;\n        }\n    }\n\n    return browser;\n}\n","export default function getBrowserLanguage(): string {\n    return (navigator.languages && navigator.languages.length && navigator.languages[0]) || navigator.language || 'en';\n}\n","export default function getCSSProperty(element?: HTMLElement, property?: string, inline?: boolean): string | null {\n    if (element && property) {\n        return inline ? element?.style?.getPropertyValue(property) : getComputedStyle(element).getPropertyValue(property);\n    }\n\n    return null;\n}\n","export default function getCursorOffset(element: Element, prevText: string, nextText: string, currentText: string): { top: number | string; left: number | string } {\n    if (element) {\n        const style = getComputedStyle(element);\n        const ghostDiv = document.createElement('div');\n\n        ghostDiv.style.position = 'absolute';\n        ghostDiv.style.top = '0px';\n        ghostDiv.style.left = '0px';\n        ghostDiv.style.visibility = 'hidden';\n        ghostDiv.style.pointerEvents = 'none';\n        ghostDiv.style.overflow = style.overflow;\n        ghostDiv.style.width = style.width;\n        ghostDiv.style.height = style.height;\n        ghostDiv.style.padding = style.padding;\n        ghostDiv.style.border = style.border;\n        ghostDiv.style.overflowWrap = style.overflowWrap;\n        ghostDiv.style.whiteSpace = style.whiteSpace;\n        ghostDiv.style.lineHeight = style.lineHeight;\n        ghostDiv.innerHTML = prevText.replace(/\\r\\n|\\r|\\n/g, '<br />');\n\n        const ghostSpan = document.createElement('span');\n\n        ghostSpan.textContent = currentText;\n        ghostDiv.appendChild(ghostSpan);\n\n        const text = document.createTextNode(nextText);\n\n        ghostDiv.appendChild(text);\n        document.body.appendChild(ghostDiv);\n\n        const { offsetLeft, offsetTop, clientHeight } = ghostSpan;\n\n        document.body.removeChild(ghostDiv);\n\n        return {\n            left: Math.abs(offsetLeft - element.scrollLeft),\n            top: Math.abs(offsetTop - element.scrollTop) + clientHeight\n        };\n    }\n\n    return {\n        top: 'auto',\n        left: 'auto'\n    };\n}\n","import find from './find';\n\nexport default function getFocusableElements(element: Element, selector: string = ''): Element[] {\n    const focusableElements = find(\n        element,\n        `button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`\n    );\n\n    const visibleFocusableElements: Element[] = [];\n\n    for (const focusableElement of focusableElements) {\n        if (getComputedStyle(focusableElement).display != 'none' && getComputedStyle(focusableElement).visibility != 'hidden') visibleFocusableElements.push(focusableElement);\n    }\n\n    return visibleFocusableElements;\n}\n","import getFocusableElements from './getFocusableElements';\n\nexport default function getFirstFocusableElement(element: Element, selector?: string): Element | null {\n    const focusableElements = getFocusableElements(element, selector);\n\n    return focusableElements.length > 0 ? focusableElements[0] : null;\n}\n","export default function getHeight(element: HTMLElement): number {\n    if (element) {\n        let height = element.offsetHeight;\n        const style = getComputedStyle(element);\n\n        height -= parseFloat(style.paddingTop) + parseFloat(style.paddingBottom) + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n\n        return height;\n    }\n\n    return 0;\n}\n","export default function getHiddenElementOuterHeight(element: HTMLElement): number {\n    if (element) {\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        const elementHeight = element.offsetHeight;\n\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n\n        return elementHeight;\n    }\n\n    return 0;\n}\n","export default function getHiddenElementOuterWidth(element: HTMLElement): number {\n    if (element) {\n        element.style.visibility = 'hidden';\n        element.style.display = 'block';\n        const elementWidth = element.offsetWidth;\n\n        element.style.display = 'none';\n        element.style.visibility = 'visible';\n\n        return elementWidth;\n    }\n\n    return 0;\n}\n","import getParentNode from './getParentNode';\n\nexport default function getIndex(element: HTMLElement): number {\n    if (element) {\n        const children = getParentNode(element)?.childNodes;\n        let num = 0;\n\n        if (children) {\n            for (let i = 0; i < children.length; i++) {\n                if (children[i] === element) return num;\n                if (children[i].nodeType === 1) num++;\n            }\n        }\n    }\n\n    return -1;\n}\n","export default function getInnerWidth(element: HTMLElement): number {\n    if (element) {\n        let width = element.offsetWidth;\n        const style = getComputedStyle(element);\n\n        width -= parseFloat(style.borderLeft) + parseFloat(style.borderRight);\n\n        return width;\n    }\n\n    return 0;\n}\n","import getFocusableElements from './getFocusableElements';\n\nexport default function getLastFocusableElement(element: Element, selector?: string): Element | null {\n    const focusableElements = getFocusableElements(element, selector);\n\n    return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;\n}\n","export default function getNextElementSibling(element: Element, selector: string): Element | null {\n    let nextElement = element.nextElementSibling;\n\n    while (nextElement) {\n        if (nextElement.matches(selector)) {\n            return nextElement;\n        } else {\n            nextElement = nextElement.nextElementSibling;\n        }\n    }\n\n    return null;\n}\n","import getFocusableElements from './getFocusableElements';\n\nexport default function getNextFocusableElement(container: Element, element: Element, selector?: string): Element | null {\n    const focusableElements: Element[] = getFocusableElements(container, selector);\n    const index = focusableElements.length > 0 ? focusableElements.findIndex((el) => el === element) : -1;\n    const nextIndex = index > -1 && focusableElements.length >= index + 1 ? index + 1 : -1;\n\n    return nextIndex > -1 ? focusableElements[nextIndex] : null;\n}\n","import getScrollLeft from './getScrollLeft';\n\nexport default function getOffset(element?: Element | null): { top: number | string; left: number | string } {\n    if (element) {\n        const rect = element.getBoundingClientRect();\n\n        return {\n            top: rect.top + (window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0),\n            left: rect.left + (window.pageXOffset || getScrollLeft(document.documentElement) || getScrollLeft(document.body) || 0)\n        };\n    }\n\n    return {\n        top: 'auto',\n        left: 'auto'\n    };\n}\n","export default function getOuterHeight(element: HTMLElement, margin?: boolean): number {\n    if (element) {\n        let height = element.offsetHeight;\n\n        if (margin) {\n            const style = getComputedStyle(element);\n\n            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);\n        }\n\n        return height;\n    }\n\n    return 0;\n}\n","import getParentNode from './getParentNode';\n\nexport default function getParents(element: Node, parents: ParentNode[] = []): ParentNode[] {\n    const parent = getParentNode(element);\n\n    return parent === null ? parents : getParents(parent, parents.concat([parent]));\n}\n","export default function getPreviousElementSibling(element: Element, selector: string): Element | null {\n    let previousElement = element.previousElementSibling;\n\n    while (previousElement) {\n        if (previousElement.matches(selector)) {\n            return previousElement;\n        } else {\n            previousElement = previousElement.previousElementSibling;\n        }\n    }\n\n    return null;\n}\n","import findSingle from './findSingle';\nimport getParents from './getParents';\n\nexport default function getScrollableParents(element: Element): Element[] {\n    const scrollableParents = [];\n\n    if (element) {\n        const parents = getParents(element) as HTMLElement[];\n        const overflowRegex = /(auto|scroll)/;\n\n        const overflowCheck = (node: Element) => {\n            try {\n                const styleDeclaration = window['getComputedStyle'](node, null);\n\n                return overflowRegex.test(styleDeclaration.getPropertyValue('overflow')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowX')) || overflowRegex.test(styleDeclaration.getPropertyValue('overflowY'));\n            } catch {\n                return false;\n            }\n        };\n\n        for (const parent of parents) {\n            const scrollSelectors = parent.nodeType === 1 && parent.dataset['scrollselectors'];\n\n            if (scrollSelectors) {\n                const selectors = scrollSelectors.split(',');\n\n                for (const selector of selectors) {\n                    const el = findSingle(parent, selector);\n\n                    if (el && overflowCheck(el)) {\n                        scrollableParents.push(el);\n                    }\n                }\n            }\n\n            if (parent.nodeType !== 9 && overflowCheck(parent)) {\n                scrollableParents.push(parent);\n            }\n        }\n    }\n\n    return scrollableParents;\n}\n","export default function getSelection(): string | undefined {\n    if (window.getSelection) return (window.getSelection() as any).toString();\n    else if (document.getSelection) return (document.getSelection() as any).toString();\n\n    return undefined;\n}\n","export default function getUserAgent(): string {\n    return navigator.userAgent;\n}\n","export default function getWidth(element: HTMLElement): number {\n    if (element) {\n        let width = element.offsetWidth;\n        const style = getComputedStyle(element);\n\n        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) + parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);\n\n        return width;\n    }\n\n    return 0;\n}\n","export default function hasCSSAnimation(element: Element): boolean {\n    if (element) {\n        const style = getComputedStyle(element);\n        const animationDuration = parseFloat(style.getPropertyValue('animation-duration') || '0');\n\n        return animationDuration > 0;\n    }\n\n    return false;\n}\n","export default function hasCSSTransition(element: Element): boolean {\n    if (element) {\n        const style = getComputedStyle(element);\n        const transitionDuration = parseFloat(style.getPropertyValue('transition-duration') || '0');\n\n        return transitionDuration > 0;\n    }\n\n    return false;\n}\n","export default function invokeElementMethod<T extends keyof Element>(element: Element, methodName: T, args?: unknown[]): void {\n    const method = element[methodName];\n\n    if (typeof method === 'function') {\n        (method as (...args: unknown[]) => void).apply(element, args ?? []);\n    }\n}\n","export default function isAndroid(): boolean {\n    return /(android)/i.test(navigator.userAgent);\n}\n","import getAttribute from './getAttribute';\nimport isElement from './isElement';\n\nexport default function isAttributeEquals(element: Element, name: string, value: any): boolean {\n    return isElement(element) ? getAttribute(element, name) === value : false;\n}\n","import isAttributeEquals from './isAttributeEquals';\n\nexport default function isAttributeNotEquals(element: Element, name: string, value: any): boolean {\n    return !isAttributeEquals(element, name, value);\n}\n","export default function isClickable(element: Element): boolean {\n    if (element) {\n        const targetNode = element.nodeName;\n        const parentNode = element.parentElement && element.parentElement.nodeName;\n\n        return (\n            targetNode === 'INPUT' ||\n            targetNode === 'TEXTAREA' ||\n            targetNode === 'BUTTON' ||\n            targetNode === 'A' ||\n            parentNode === 'INPUT' ||\n            parentNode === 'TEXTAREA' ||\n            parentNode === 'BUTTON' ||\n            parentNode === 'A' ||\n            !!element.closest('.p-button, .p-checkbox, .p-radiobutton') // @todo Add [data-pc-section=\"button\"]\n        );\n    }\n\n    return false;\n}\n","export default function isClient(): boolean {\n    return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n}\n","import isElement from './isElement';\n\nexport default function isFocusableElement(element: unknown, selector: string = ''): boolean {\n    return isElement(element)\n        ? (element as Element).matches(`button:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [href][clientHeight][clientWidth]:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            input:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            select:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            textarea:not([tabindex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [tabIndex]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector},\n            [contenteditable]:not([tabIndex = \"-1\"]):not([disabled]):not([style*=\"display:none\"]):not([hidden])${selector}`)\n        : false;\n}\n","export default function isVisible(element?: HTMLElement): boolean {\n    return !!(element && element.offsetParent != null);\n}\n","import isVisible from './isVisible';\n\nexport default function isHidden(element: HTMLElement): boolean {\n    return !isVisible(element);\n}\n","export default function isIOS(): boolean {\n    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n}\n","export default function isRTL(element?: HTMLElement): boolean {\n    return element ? getComputedStyle(element).direction === 'rtl' : false;\n}\n","import isClient from './isClient';\n\nexport default function isServer(): boolean {\n    return !isClient();\n}\n","export default function isTouchDevice(): boolean {\n    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || (navigator as Partial<Navigator & { msMaxTouchPoints?: number }>).msMaxTouchPoints! > 0;\n}\n","import calculateScrollbarWidth from './calculateScrollbarWidth';\nimport getHiddenElementOuterHeight from './getHiddenElementOuterHeight';\nimport getHiddenElementOuterWidth from './getHiddenElementOuterWidth';\nimport getOffset from './getOffset';\nimport getOuterHeight from './getOuterHeight';\nimport getOuterWidth from './getOuterWidth';\nimport getViewport from './getViewport';\n\nexport default function nestedPosition(element: HTMLElement, level: number): void {\n    if (element) {\n        const parentItem = element.parentElement;\n        const elementOffset = getOffset(parentItem);\n        const viewport = getViewport();\n        const sublistWidth = element.offsetParent ? element.offsetWidth : getHiddenElementOuterWidth(element);\n        const sublistHeight = element.offsetParent ? element.offsetHeight : getHiddenElementOuterHeight(element);\n        const itemOuterWidth = getOuterWidth(parentItem?.children?.[0]);\n        const itemOuterHeight = getOuterHeight(parentItem?.children?.[0] as HTMLElement);\n\n        let left: string = '';\n        let top: string = '';\n\n        if ((elementOffset.left as number) + itemOuterWidth + sublistWidth > viewport.width - calculateScrollbarWidth()) {\n            if ((elementOffset.left as number) < sublistWidth) {\n                // for too small screens\n                if (level % 2 === 1) {\n                    left = (elementOffset.left as number) ? '-' + (elementOffset.left as number) + 'px' : '100%';\n                } else if (level % 2 === 0) {\n                    left = viewport.width - sublistWidth - calculateScrollbarWidth() + 'px';\n                }\n            } else {\n                left = '-100%';\n            }\n        } else {\n            left = '100%';\n        }\n\n        // getBoundingClientRect returns a top position from the current visible viewport area\n        if (element.getBoundingClientRect().top + itemOuterHeight + sublistHeight > viewport.height) {\n            top = `-${sublistHeight - itemOuterHeight}px`;\n        } else {\n            top = '0px';\n        }\n\n        element.style.top = top;\n        element.style.insetInlineStart = left;\n    }\n}\n","export default function remove(element: Element) {\n    if (element) {\n        if (!('remove' in Element.prototype)) element.parentNode?.removeChild(element);\n        else element.remove();\n    }\n}\n","import toElement from './toElement';\n\nexport default function removeChild(element: unknown, child: Node) {\n    const target = toElement(element);\n\n    if (target) target.removeChild(child);\n    else throw new Error('Cannot remove ' + child + ' from ' + element);\n}\n","import isExist from './isExist';\n\nexport default function removeStyleTag(element: Node): Node | null {\n    if (isExist(element)) {\n        try {\n            element.parentNode?.removeChild(element);\n        } catch {\n            // style element may have already been removed in a fast refresh\n        }\n\n        return null;\n    }\n\n    return element;\n}\n","import getOuterHeight from './getOuterHeight';\n\nexport default function scrollInView(container: HTMLElement, item: HTMLElement): void {\n    const borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');\n    const borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;\n    const paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');\n    const paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;\n    const containerRect = container.getBoundingClientRect();\n    const itemRect = item.getBoundingClientRect();\n    const offset = itemRect.top + document.body.scrollTop - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;\n    const scroll = container.scrollTop;\n    const elementHeight = container.clientHeight;\n    const itemHeight = getOuterHeight(item);\n\n    if (offset < 0) {\n        container.scrollTop = scroll + offset;\n    } else if (offset + itemHeight > elementHeight) {\n        container.scrollTop = scroll + offset - elementHeight + itemHeight;\n    }\n}\n","import isElement from './isElement';\n\nexport default function setAttribute(element: HTMLElement, attribute: string = '', value: any): void {\n    if (isElement(element) && value !== null && value !== undefined) {\n        element.setAttribute(attribute, value);\n    }\n}\n","export default function setCSSProperty(element?: HTMLElement, property?: string, value: any = null, priority?: string): void {\n    property && element?.style?.setProperty(property, value, priority);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}