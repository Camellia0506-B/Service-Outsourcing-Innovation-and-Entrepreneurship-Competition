{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.filter.js\");\nrequire(\"core-js/modules/es.iterator.for-each.js\");\nrequire(\"core-js/modules/es.iterator.map.js\");\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vue = require('vue');\nvar lodashUnified = require('lodash-unified');\nvar menu = require('./menu.js');\nvar store = require('./store.js');\nvar node = require('./node.js');\nvar config = require('./config.js');\nvar utils = require('./utils.js');\nvar types = require('./types.js');\nvar pluginVue_exportHelper = require('../../../_virtual/plugin-vue_export-helper.js');\nvar arrays = require('../../../utils/arrays.js');\nvar scroll = require('../../../utils/dom/scroll.js');\nvar aria$1 = require('../../../utils/dom/aria.js');\nvar event = require('../../../constants/event.js');\nvar index = require('../../../hooks/use-namespace/index.js');\nvar types$1 = require('../../../utils/types.js');\nvar core = require('@vueuse/core');\nvar aria = require('../../../constants/aria.js');\nconst _sfc_main = vue.defineComponent({\n  name: \"ElCascaderPanel\",\n  components: {\n    ElCascaderMenu: menu[\"default\"]\n  },\n  props: {\n    ...config.CommonProps,\n    border: {\n      type: Boolean,\n      default: true\n    },\n    renderLabel: Function\n  },\n  emits: [event.UPDATE_MODEL_EVENT, event.CHANGE_EVENT, \"close\", \"expand-change\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    let manualChecked = false;\n    const ns = index.useNamespace(\"cascader\");\n    const config$1 = config.useCascaderConfig(props);\n    let store$1 = null;\n    const initialLoaded = vue.ref(true);\n    const menuList = vue.ref([]);\n    const checkedValue = vue.ref(null);\n    const menus = vue.ref([]);\n    const expandingNode = vue.ref(null);\n    const checkedNodes = vue.ref([]);\n    const isHoverMenu = vue.computed(() => config$1.value.expandTrigger === \"hover\");\n    const renderLabelFn = vue.computed(() => props.renderLabel || slots.default);\n    const initStore = () => {\n      const {\n        options\n      } = props;\n      const cfg = config$1.value;\n      manualChecked = false;\n      store$1 = new store[\"default\"](options, cfg);\n      menus.value = [store$1.getNodes()];\n      if (cfg.lazy && types$1.isEmpty(props.options)) {\n        initialLoaded.value = false;\n        lazyLoad(void 0, list => {\n          if (list) {\n            store$1 = new store[\"default\"](list, cfg);\n            menus.value = [store$1.getNodes()];\n          }\n          initialLoaded.value = true;\n          syncCheckedValue(false, true);\n        });\n      } else {\n        syncCheckedValue(false, true);\n      }\n    };\n    const lazyLoad = (node$1, cb) => {\n      const cfg = config$1.value;\n      node$1 = node$1 || new node[\"default\"]({}, cfg, void 0, true);\n      node$1.loading = true;\n      const resolve = dataList => {\n        const _node = node$1;\n        const parent = _node.root ? null : _node;\n        dataList && (store$1 == null ? void 0 : store$1.appendNodes(dataList, parent));\n        _node.loading = false;\n        _node.loaded = true;\n        _node.childrenData = _node.childrenData || [];\n        cb && cb(dataList);\n      };\n      cfg.lazyLoad(node$1, resolve);\n    };\n    const expandNode = (node, silent) => {\n      var _a;\n      const {\n        level\n      } = node;\n      const newMenus = menus.value.slice(0, level);\n      let newExpandingNode;\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2];\n      } else {\n        newExpandingNode = node;\n        newMenus.push(node.children);\n      }\n      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {\n        expandingNode.value = node;\n        menus.value = newMenus;\n        !silent && emit(\"expand-change\", (node == null ? void 0 : node.pathValues) || []);\n      }\n    };\n    const handleCheckChange = (node, checked, emitClose = true) => {\n      const {\n        checkStrictly,\n        multiple\n      } = config$1.value;\n      const oldNode = checkedNodes.value[0];\n      manualChecked = true;\n      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));\n      node.doCheck(checked);\n      calculateCheckedValue();\n      emitClose && !multiple && !checkStrictly && emit(\"close\");\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node);\n    };\n    const expandParentNode = node => {\n      if (!node) return;\n      node = node.parent;\n      expandParentNode(node);\n      node && expandNode(node);\n    };\n    const getFlattedNodes = leafOnly => {\n      return store$1 == null ? void 0 : store$1.getFlattedNodes(leafOnly);\n    };\n    const getCheckedNodes = leafOnly => {\n      var _a;\n      return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter(node => node.checked !== false);\n    };\n    const clearCheckedNodes = () => {\n      checkedNodes.value.forEach(node => node.doCheck(false));\n      calculateCheckedValue();\n      menus.value = menus.value.slice(0, 1);\n      expandingNode.value = null;\n      emit(\"expand-change\", []);\n    };\n    const calculateCheckedValue = () => {\n      var _a;\n      const {\n        checkStrictly,\n        multiple\n      } = config$1.value;\n      const oldNodes = checkedNodes.value;\n      const newNodes = getCheckedNodes(!checkStrictly);\n      const nodes = utils.sortByOriginalOrder(oldNodes, newNodes);\n      const values = nodes.map(node => node.valueByOption);\n      checkedNodes.value = nodes;\n      checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;\n    };\n    const syncCheckedValue = (loaded = false, forced = false) => {\n      const {\n        modelValue\n      } = props;\n      const {\n        lazy,\n        multiple,\n        checkStrictly\n      } = config$1.value;\n      const leafOnly = !checkStrictly;\n      if (!initialLoaded.value || manualChecked || !forced && lodashUnified.isEqual(modelValue, checkedValue.value)) return;\n      if (lazy && !loaded) {\n        const values = arrays.unique(lodashUnified.flattenDeep(arrays.castArray(modelValue)));\n        const nodes = values.map(val => store$1 == null ? void 0 : store$1.getNodeByValue(val)).filter(node => !!node && !node.loaded && !node.loading);\n        if (nodes.length) {\n          nodes.forEach(node => {\n            lazyLoad(node, () => syncCheckedValue(false, forced));\n          });\n        } else {\n          syncCheckedValue(true, forced);\n        }\n      } else {\n        const values = multiple ? arrays.castArray(modelValue) : [modelValue];\n        const nodes = arrays.unique(values.map(val => store$1 == null ? void 0 : store$1.getNodeByValue(val, leafOnly)));\n        syncMenuState(nodes, forced);\n        checkedValue.value = lodashUnified.cloneDeep(modelValue);\n      }\n    };\n    const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {\n      const {\n        checkStrictly\n      } = config$1.value;\n      const oldNodes = checkedNodes.value;\n      const newNodes = newCheckedNodes.filter(node => !!node && (checkStrictly || node.isLeaf));\n      const oldExpandingNode = store$1 == null ? void 0 : store$1.getSameNode(expandingNode.value);\n      const newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach(node => expandNode(node, true));\n      } else {\n        expandingNode.value = null;\n      }\n      oldNodes.forEach(node => node.doCheck(false));\n      vue.reactive(newNodes).forEach(node => node.doCheck(true));\n      checkedNodes.value = newNodes;\n      vue.nextTick(scrollToExpandingNode);\n    };\n    const scrollToExpandingNode = () => {\n      if (!core.isClient) return;\n      menuList.value.forEach(menu => {\n        const menuElement = menu == null ? void 0 : menu.$el;\n        if (menuElement) {\n          const container = menuElement.querySelector(`.${ns.namespace.value}-scrollbar__wrap`);\n          const activeNode = menuElement.querySelector(`.${ns.b(\"node\")}.${ns.is(\"active\")}`) || menuElement.querySelector(`.${ns.b(\"node\")}.in-active-path`);\n          scroll.scrollIntoView(container, activeNode);\n        }\n      });\n    };\n    const handleKeyDown = e => {\n      const target = e.target;\n      const {\n        code\n      } = e;\n      switch (code) {\n        case aria.EVENT_CODE.up:\n        case aria.EVENT_CODE.down:\n          {\n            e.preventDefault();\n            const distance = code === aria.EVENT_CODE.up ? -1 : 1;\n            aria$1.focusNode(aria$1.getSibling(target, distance, `.${ns.b(\"node\")}[tabindex=\"-1\"]`));\n            break;\n          }\n        case aria.EVENT_CODE.left:\n          {\n            e.preventDefault();\n            const preMenu = menuList.value[utils.getMenuIndex(target) - 1];\n            const expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(`.${ns.b(\"node\")}[aria-expanded=\"true\"]`);\n            aria$1.focusNode(expandedNode);\n            break;\n          }\n        case aria.EVENT_CODE.right:\n          {\n            e.preventDefault();\n            const nextMenu = menuList.value[utils.getMenuIndex(target) + 1];\n            const firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(`.${ns.b(\"node\")}[tabindex=\"-1\"]`);\n            aria$1.focusNode(firstNode);\n            break;\n          }\n        case aria.EVENT_CODE.enter:\n        case aria.EVENT_CODE.numpadEnter:\n          utils.checkNode(target);\n          break;\n      }\n    };\n    vue.provide(types.CASCADER_PANEL_INJECTION_KEY, vue.reactive({\n      config: config$1,\n      expandingNode,\n      checkedNodes,\n      isHoverMenu,\n      initialLoaded,\n      renderLabelFn,\n      lazyLoad,\n      expandNode,\n      handleCheckChange\n    }));\n    vue.watch([config$1, () => props.options], initStore, {\n      deep: true,\n      immediate: true\n    });\n    vue.watch(() => props.modelValue, () => {\n      manualChecked = false;\n      syncCheckedValue();\n    }, {\n      deep: true\n    });\n    vue.watch(() => checkedValue.value, val => {\n      if (!lodashUnified.isEqual(val, props.modelValue)) {\n        emit(event.UPDATE_MODEL_EVENT, val);\n        emit(event.CHANGE_EVENT, val);\n      }\n    });\n    vue.onBeforeUpdate(() => menuList.value = []);\n    vue.onMounted(() => !types$1.isEmpty(props.modelValue) && syncCheckedValue());\n    return {\n      ns,\n      menuList,\n      menus,\n      checkedNodes,\n      handleKeyDown,\n      handleCheckChange,\n      getFlattedNodes,\n      getCheckedNodes,\n      clearCheckedNodes,\n      calculateCheckedValue,\n      scrollToExpandingNode\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_el_cascader_menu = vue.resolveComponent(\"el-cascader-menu\");\n  return vue.openBlock(), vue.createElementBlock(\"div\", {\n    class: vue.normalizeClass([_ctx.ns.b(\"panel\"), _ctx.ns.is(\"bordered\", _ctx.border)]),\n    onKeydown: _ctx.handleKeyDown\n  }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.menus, (menu, index) => {\n    return vue.openBlock(), vue.createBlock(_component_el_cascader_menu, {\n      key: index,\n      ref_for: true,\n      ref: item => _ctx.menuList[index] = item,\n      index,\n      nodes: [...menu]\n    }, {\n      empty: vue.withCtx(() => [vue.renderSlot(_ctx.$slots, \"empty\")]),\n      _: 2\n    }, 1032, [\"index\", \"nodes\"]);\n  }), 128))], 42, [\"onKeydown\"]);\n}\nvar CascaderPanel = /* @__PURE__ */pluginVue_exportHelper[\"default\"](_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"index.vue\"]]);\nexports[\"default\"] = CascaderPanel;","map":{"version":3,"names":["_sfc_main","vue","defineComponent","name","components","ElCascaderMenu","menu","props","config","CommonProps","border","type","Boolean","default","renderLabel","Function","emits","event","UPDATE_MODEL_EVENT","CHANGE_EVENT","setup","emit","slots","manualChecked","ns","index","useNamespace","config$1","useCascaderConfig","store$1","initialLoaded","ref","menuList","checkedValue","menus","expandingNode","checkedNodes","isHoverMenu","computed","value","expandTrigger","renderLabelFn","initStore","options","cfg","store","getNodes","lazy","types$1","isEmpty","lazyLoad","list","syncCheckedValue","node$1","cb","node","loading","resolve","dataList","_node","parent","root","appendNodes","loaded","childrenData","expandNode","silent","_a","level","newMenus","slice","newExpandingNode","isLeaf","pathNodes","push","children","uid","pathValues","handleCheckChange","checked","emitClose","checkStrictly","multiple","oldNode","doCheck","calculateCheckedValue","expandParentNode","getFlattedNodes","leafOnly","getCheckedNodes","filter","clearCheckedNodes","forEach","oldNodes","newNodes","nodes","utils","sortByOriginalOrder","values","map","valueByOption","forced","modelValue","lodashUnified","isEqual","arrays","unique","flattenDeep","castArray","val","getNodeByValue","length","syncMenuState","cloneDeep","newCheckedNodes","reserveExpandingState","oldExpandingNode","getSameNode","reactive","nextTick","scrollToExpandingNode","core","isClient","menuElement","$el","container","querySelector","namespace","activeNode","b","is","scroll","scrollIntoView","handleKeyDown","e","target","code","aria","EVENT_CODE","up","down","preventDefault","distance","aria$1","focusNode","getSibling","left","preMenu","getMenuIndex","expandedNode","right","nextMenu","firstNode","enter","numpadEnter","checkNode","provide","types","CASCADER_PANEL_INJECTION_KEY","watch","deep","immediate","onBeforeUpdate","onMounted","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","_component_el_cascader_menu","resolveComponent","openBlock","createElementBlock","class","normalizeClass","onKeydown","Fragment","renderList","createBlock","key","ref_for","item","empty","withCtx","renderSlot","$slots","_","CascaderPanel","pluginVue_exportHelper"],"sources":["../../../../../../packages/components/cascader-panel/src/index.vue"],"sourcesContent":["<template>\n  <div\n    :class=\"[ns.b('panel'), ns.is('bordered', border)]\"\n    @keydown=\"handleKeyDown\"\n  >\n    <el-cascader-menu\n      v-for=\"(menu, index) in menus\"\n      :key=\"index\"\n      :ref=\"(item) => (menuList[index] = item)\"\n      :index=\"index\"\n      :nodes=\"[...menu]\"\n    >\n      <template #empty>\n        <slot name=\"empty\" />\n      </template>\n    </el-cascader-menu>\n  </div>\n</template>\n\n<script lang=\"ts\">\n// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUpdate,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  watch,\n} from 'vue'\nimport { cloneDeep, flattenDeep, isEqual } from 'lodash-unified'\nimport {\n  castArray,\n  focusNode,\n  getSibling,\n  isClient,\n  isEmpty,\n  scrollIntoView,\n  unique,\n} from '@element-plus/utils'\nimport {\n  CHANGE_EVENT,\n  EVENT_CODE,\n  UPDATE_MODEL_EVENT,\n} from '@element-plus/constants'\nimport { useNamespace } from '@element-plus/hooks'\n\nimport ElCascaderMenu from './menu.vue'\nimport Store from './store'\nimport Node from './node'\nimport { CommonProps, useCascaderConfig } from './config'\nimport { checkNode, getMenuIndex, sortByOriginalOrder } from './utils'\nimport { CASCADER_PANEL_INJECTION_KEY } from './types'\n\nimport type { PropType } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  default as CascaderNode,\n  CascaderNodeValue,\n  CascaderOption,\n  CascaderValue,\n  RenderLabel,\n} from './node'\n\nimport type { ElCascaderPanelContext } from './types'\n\nexport default defineComponent({\n  name: 'ElCascaderPanel',\n\n  components: {\n    ElCascaderMenu,\n  },\n\n  props: {\n    ...CommonProps,\n    border: {\n      type: Boolean,\n      default: true,\n    },\n    renderLabel: Function as PropType<RenderLabel>,\n  },\n\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'close', 'expand-change'],\n\n  setup(props, { emit, slots }) {\n    // for interrupt sync check status in lazy mode\n    let manualChecked = false\n\n    const ns = useNamespace('cascader')\n    const config = useCascaderConfig(props)\n\n    let store: Nullable<Store> = null\n    const initialLoaded = ref(true)\n    const menuList = ref<any[]>([])\n    const checkedValue = ref<Nullable<CascaderValue>>(null)\n    const menus = ref<CascaderNode[][]>([])\n    const expandingNode = ref<Nullable<CascaderNode>>(null)\n    const checkedNodes = ref<CascaderNode[]>([])\n\n    const isHoverMenu = computed(() => config.value.expandTrigger === 'hover')\n    const renderLabelFn = computed(() => props.renderLabel || slots.default)\n\n    const initStore = () => {\n      const { options } = props\n      const cfg = config.value\n\n      manualChecked = false\n      store = new Store(options, cfg)\n      menus.value = [store.getNodes()]\n\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded.value = false\n        lazyLoad(undefined, (list) => {\n          if (list) {\n            store = new Store(list, cfg)\n            menus.value = [store.getNodes()]\n          }\n          initialLoaded.value = true\n          syncCheckedValue(false, true)\n        })\n      } else {\n        syncCheckedValue(false, true)\n      }\n    }\n\n    const lazyLoad: ElCascaderPanelContext['lazyLoad'] = (node, cb) => {\n      const cfg = config.value\n      node! = node || new Node({}, cfg, undefined, true)\n      node.loading = true\n\n      const resolve = (dataList: CascaderOption[]) => {\n        const _node = node as Node\n        const parent = _node.root ? null : _node\n        dataList && store?.appendNodes(dataList, parent as any)\n        _node.loading = false\n        _node.loaded = true\n        _node.childrenData = _node.childrenData || []\n        cb && cb(dataList)\n      }\n\n      cfg.lazyLoad(node, resolve as any)\n    }\n\n    const expandNode: ElCascaderPanelContext['expandNode'] = (node, silent) => {\n      const { level } = node\n      const newMenus = menus.value.slice(0, level)\n      let newExpandingNode: Nullable<CascaderNode>\n\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2]\n      } else {\n        newExpandingNode = node\n        newMenus.push(node.children)\n      }\n\n      if (expandingNode.value?.uid !== newExpandingNode?.uid) {\n        expandingNode.value = node\n        menus.value = newMenus\n        !silent && emit('expand-change', node?.pathValues || [])\n      }\n    }\n\n    const handleCheckChange: ElCascaderPanelContext['handleCheckChange'] = (\n      node,\n      checked,\n      emitClose = true\n    ) => {\n      const { checkStrictly, multiple } = config.value\n      const oldNode = checkedNodes.value[0]\n      manualChecked = true\n\n      !multiple && oldNode?.doCheck(false)\n      node.doCheck(checked)\n      calculateCheckedValue()\n      emitClose && !multiple && !checkStrictly && emit('close')\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node)\n    }\n\n    const expandParentNode = (node) => {\n      if (!node) return\n      node = node.parent\n      expandParentNode(node)\n      node && expandNode(node)\n    }\n\n    const getFlattedNodes = (leafOnly: boolean) => {\n      return store?.getFlattedNodes(leafOnly)\n    }\n\n    const getCheckedNodes = (leafOnly: boolean) => {\n      return getFlattedNodes(leafOnly)?.filter((node) => node.checked !== false)\n    }\n\n    const clearCheckedNodes = () => {\n      checkedNodes.value.forEach((node) => node.doCheck(false))\n      calculateCheckedValue()\n      menus.value = menus.value.slice(0, 1)\n      expandingNode.value = null\n      emit('expand-change', [])\n    }\n\n    const calculateCheckedValue = () => {\n      const { checkStrictly, multiple } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = getCheckedNodes(!checkStrictly)!\n      // ensure the original order\n      const nodes = sortByOriginalOrder(oldNodes, newNodes)\n      const values = nodes.map((node) => node.valueByOption)\n      checkedNodes.value = nodes\n      checkedValue.value = multiple ? values : values[0] ?? null\n    }\n\n    const syncCheckedValue = (loaded = false, forced = false) => {\n      const { modelValue } = props\n      const { lazy, multiple, checkStrictly } = config.value\n      const leafOnly = !checkStrictly\n\n      if (\n        !initialLoaded.value ||\n        manualChecked ||\n        (!forced && isEqual(modelValue, checkedValue.value))\n      )\n        return\n\n      if (lazy && !loaded) {\n        const values: CascaderNodeValue[] = unique(\n          flattenDeep(castArray(modelValue))\n        )\n        const nodes = values\n          .map((val) => store?.getNodeByValue(val))\n          .filter((node) => !!node && !node.loaded && !node.loading) as Node[]\n\n        if (nodes.length) {\n          nodes.forEach((node) => {\n            lazyLoad(node, () => syncCheckedValue(false, forced))\n          })\n        } else {\n          syncCheckedValue(true, forced)\n        }\n      } else {\n        const values = multiple ? castArray(modelValue) : [modelValue]\n        const nodes = unique(\n          values.map((val) => store?.getNodeByValue(val, leafOnly))\n        ) as Node[]\n        syncMenuState(nodes, forced)\n        checkedValue.value = cloneDeep(modelValue)\n      }\n    }\n\n    const syncMenuState = (\n      newCheckedNodes: CascaderNode[],\n      reserveExpandingState = true\n    ) => {\n      const { checkStrictly } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = newCheckedNodes.filter(\n        (node) => !!node && (checkStrictly || node.isLeaf)\n      )\n      const oldExpandingNode = store?.getSameNode(expandingNode.value!)\n      const newExpandingNode =\n        (reserveExpandingState && oldExpandingNode) || newNodes[0]\n\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true))\n      } else {\n        expandingNode.value = null\n      }\n\n      oldNodes.forEach((node) => node.doCheck(false))\n      reactive(newNodes).forEach((node) => node.doCheck(true))\n      checkedNodes.value = newNodes\n      nextTick(scrollToExpandingNode)\n    }\n\n    const scrollToExpandingNode = () => {\n      if (!isClient) return\n\n      menuList.value.forEach((menu) => {\n        const menuElement = menu?.$el\n        if (menuElement) {\n          const container = menuElement.querySelector(\n            `.${ns.namespace.value}-scrollbar__wrap`\n          )\n          const activeNode =\n            menuElement.querySelector(`.${ns.b('node')}.${ns.is('active')}`) ||\n            menuElement.querySelector(`.${ns.b('node')}.in-active-path`)\n          scrollIntoView(container, activeNode)\n        }\n      })\n    }\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const target = e.target as HTMLElement\n      const { code } = e\n\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down: {\n          e.preventDefault()\n          const distance = code === EVENT_CODE.up ? -1 : 1\n          focusNode(\n            getSibling(target, distance, `.${ns.b('node')}[tabindex=\"-1\"]`)\n          )\n          break\n        }\n        case EVENT_CODE.left: {\n          e.preventDefault()\n          const preMenu = menuList.value[getMenuIndex(target) - 1]\n          const expandedNode = preMenu?.$el.querySelector(\n            `.${ns.b('node')}[aria-expanded=\"true\"]`\n          )\n          focusNode(expandedNode)\n          break\n        }\n        case EVENT_CODE.right: {\n          e.preventDefault()\n          const nextMenu = menuList.value[getMenuIndex(target) + 1]\n          const firstNode = nextMenu?.$el.querySelector(\n            `.${ns.b('node')}[tabindex=\"-1\"]`\n          )\n          focusNode(firstNode)\n          break\n        }\n        case EVENT_CODE.enter:\n        case EVENT_CODE.numpadEnter:\n          checkNode(target)\n          break\n      }\n    }\n\n    provide(\n      CASCADER_PANEL_INJECTION_KEY,\n      reactive({\n        config,\n        expandingNode,\n        checkedNodes,\n        isHoverMenu,\n        initialLoaded,\n        renderLabelFn,\n        lazyLoad,\n        expandNode,\n        handleCheckChange,\n      })\n    )\n\n    watch([config, () => props.options], initStore, {\n      deep: true,\n      immediate: true,\n    })\n\n    watch(\n      () => props.modelValue,\n      () => {\n        manualChecked = false\n        syncCheckedValue()\n      },\n      {\n        deep: true,\n      }\n    )\n\n    watch(\n      () => checkedValue.value,\n      (val) => {\n        if (!isEqual(val, props.modelValue)) {\n          emit(UPDATE_MODEL_EVENT, val)\n          emit(CHANGE_EVENT, val)\n        }\n      }\n    )\n\n    onBeforeUpdate(() => (menuList.value = []))\n\n    onMounted(() => !isEmpty(props.modelValue) && syncCheckedValue())\n\n    return {\n      ns,\n      menuList,\n      menus,\n      checkedNodes,\n      handleKeyDown,\n      handleCheckChange,\n      getFlattedNodes,\n      /**\n       * @description get an array of currently selected node,(leafOnly) whether only return the leaf checked nodes, default is `false`\n       */\n      getCheckedNodes,\n      /**\n       * @description clear checked nodes\n       */\n      clearCheckedNodes,\n      calculateCheckedValue,\n      scrollToExpandingNode,\n    }\n  },\n})\n</script>\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAoEA,MAAKA,SAAA,GAAaC,GAAA,CAAAC,eAAa;EAC7BC,IAAM;EAENC,UAAY;IAAAC,cAAA,EACVC,IAAA;EAAA,CACF;EAEAC,KAAO;IACL,GAAGC,MAAA,CAAAC,WAAA;IACHC,MAAQ;MACNC,IAAM,EAAAC,OAAA;MACNC,OAAS;IAAA,CACX;IACAC,WAAa,EAAAC;EAAA,CACf;EAEAC,KAAO,GAACC,KAAA,CAAAC,kBAAoB,EAAAD,KAAA,CAAAE,YAAA,EAAc,SAAS,eAAe;EAElEC,KAAMA,CAAAb,KAAA,EAAO;IAAEc,IAAA;IAAMC;EAAA,CAAS;IAE5B,IAAIC,aAAgB;IAEd,MAAAC,EAAA,GAAKC,KAAA,CAAAC,YAAA,CAAa,UAAU;IAC5B,MAAAC,QAAA,GAASnB,MAAA,CAAAoB,iBAAA,CAAkBrB,KAAK;IAEtC,IAAIsB,OAAyB;IACvB,MAAAC,aAAA,GAAgB7B,GAAA,CAAA8B,GAAA,CAAI,IAAI;IACxB,MAAAC,QAAA,GAAW/B,GAAA,CAAA8B,GAAW,GAAE;IACxB,MAAAE,YAAA,GAAehC,GAAA,CAAA8B,GAAA,CAA6B,IAAI;IAChD,MAAAG,KAAA,GAAQjC,GAAA,CAAA8B,GAAsB,GAAE;IAChC,MAAAI,aAAA,GAAgBlC,GAAA,CAAA8B,GAAA,CAA4B,IAAI;IAChD,MAAAK,YAAA,GAAenC,GAAA,CAAA8B,GAAoB,GAAE;IAE3C,MAAMM,WAAA,GAAcpC,GAAA,CAAAqC,QAAS,OAAMX,QAAO,CAAAY,KAAA,CAAMC,aAAA,KAAkB,OAAO;IACzE,MAAMC,aAAA,GAAgBxC,GAAA,CAAAqC,QAAS,OAAM/B,KAAM,CAAAO,WAAA,IAAeQ,KAAA,CAAMT,OAAO;IAEvE,MAAM6B,SAAA,GAAYA,CAAA,KAAM;MAChB;QAAEC;MAAA,CAAY,GAAApC,KAAA;MACpB,MAAMqC,GAAA,GAAMjB,QAAO,CAAAY,KAAA;MAEHhB,aAAA;MACRM,OAAA,OAAIgB,KAAA,WAAM,CAAAF,OAAA,EAASC,GAAG;MAC9BV,KAAA,CAAMK,KAAQ,IAACV,OAAM,CAAAiB,QAAA,EAAU;MAE/B,IAAIF,GAAI,CAAAG,IAAA,IAAQC,OAAA,CAAAC,OAAQ,CAAA1C,KAAA,CAAMoC,OAAO,CAAG;QACtCb,aAAA,CAAcS,KAAQ;QACbW,QAAA,SAAYC,IAAS;UAC5B,IAAIA,IAAM;YACAtB,OAAA,OAAIgB,KAAA,WAAM,CAAAM,IAAA,EAAMP,GAAG;YAC3BV,KAAA,CAAMK,KAAQ,IAACV,OAAM,CAAAiB,QAAA,EAAU;UAAA;UAEjChB,aAAA,CAAcS,KAAQ;UACtBa,gBAAA,CAAiB,OAAO,IAAI;QAAA,CAC7B;MAAA,CACI;QACLA,gBAAA,CAAiB,OAAO,IAAI;MAAA;IAC9B,CACF;IAEM,MAAAF,QAAA,GAA+CA,CAACG,MAAA,EAAMC,EAAO;MACjE,MAAMV,GAAA,GAAMjB,QAAO,CAAAY,KAAA;MACnBc,MAAA,GAAQA,MAAA,IAAQ,IAAIE,IAAA,YAAK,EAAI,EAAAX,GAAA,EAAK,QAAW,IAAI;MACjDS,MAAA,CAAKG,OAAU;MAET,MAAAC,OAAA,GAAWC,QAA+B;QAC9C,MAAMC,KAAQ,GAAAN,MAAA;QACR,MAAAO,MAAA,GAASD,KAAM,CAAAE,IAAA,GAAO,IAAO,GAAAF,KAAA;QACvBD,QAAA,KAAA7B,OAAA,IAAmB,gBAAAA,OAAuB,CAAAiC,WAAA,CAAAJ,QAAA,EAAAE,MAAA;QACtDD,KAAA,CAAMH,OAAU;QAChBG,KAAA,CAAMI,MAAS;QACTJ,KAAA,CAAAK,YAAA,GAAeL,KAAM,CAAAK,YAAA,IAAgB,EAAC;QAC5CV,EAAA,IAAMA,EAAA,CAAGI,QAAQ;MAAA,CACnB;MAEId,GAAA,CAAAM,QAAA,CAASG,MAAA,EAAMI,OAAc;IAAA,CACnC;IAEM,MAAAQ,UAAA,GAAmDA,CAACV,IAAA,EAAMW,MAAW;MACnE,IAAAC,EAAA;MACN,MAAM;QAAWC;MAAA,IAAAb,IAAA;MACb,MAAAc,QAAA,GAAAnC,KAAA,CAAAK,KAAA,CAAA+B,KAAA,IAAAF,KAAA;MAEJ,IAAIG,gBAAa;MACI,IAAAhB,IAAA,CAAAiB,MAAA;QACdD,gBAAA,GAAAhB,IAAA,CAAAkB,SAAA,CAAAL,KAAA;MACL,CAAmB;QACVG,gBAAA,GAAUhB,IAAQ;QAC7Bc,QAAA,CAAAK,IAAA,CAAAnB,IAAA,CAAAoB,QAAA;MAEA;MACE,MAAAR,EAAA,GAAAhC,aAAsB,CAAAI,KAAA,qBAAA4B,EAAA,CAAAS,GAAA,OAAAL,gBAAA,oBAAAA,gBAAA,CAAAK,GAAA;QACtBzC,aAAc,CAAAI,KAAA,GAAAgB,IAAA;QACdrB,KAAA,CAAAK,KAAW,GAAK8B,QAAA;QAClB,CAAAH,MAAA,IAAA7C,IAAA,mBAAAkC,IAAA,oBAAAA,IAAA,CAAAsB,UAAA;MAAA;IAGF;IAKE,MAAAC,iBAAQ,GAAwBA,CAAAvB,IAAA,EAAAwB,OAAW,EAAAC,SAAA;MACrC;QAAAC,aAAuB;QAAAC;MAAA,IAAOvD,QAAA,CAAAY,KAAA;MACpB,MAAA4C,OAAA,GAAA/C,YAAA,CAAAG,KAAA;MAEfhB,aAAY,GAAS;MACtB,CAAA2D,QAAA,KAAoBC,OAAA,oBAAAA,OAAA,CAAAC,OAAA;MACE7B,IAAA,CAAA6B,OAAA,CAAAL,OAAA;MACtBM,qBAAc;MACdL,SAAA,KAAcE,QAAC,KAAYD,aAAC,IAAA5D,IAAA;MAC9B,CAAA2D,SAAA,KAAAE,QAAA,KAAAD,aAAA,IAAAK,gBAAA,CAAA/B,IAAA;IAEA,CAAM;IACJ,MAAI+B,gBAAO,GAAA/B,IAAA;MACX,KAAAA,IAAY,EACZ;MACAA,IAAA,GAAAA,IAAA,CAAAK,MAAA;MACF0B,gBAAA,CAAA/B,IAAA;MAEMA,IAAA,IAAAU,UAAA,CAAAV,IAAmB,CAAsB;IAC7C,CAAO;IACT,MAAAgC,eAAA,GAAAC,QAAA;MAEM,OAAA3D,OAAA,WAAmB,KAAsB,IAAAA,OAAA,CAAA0D,eAAA,CAAAC,QAAA;IAC7C,CAAO;IACT,MAAAC,eAAA,GAAAD,QAAA;MAEA,IAAMrB,EAAA;MACJ,QAAAA,EAAA,GAAaoB,eAAe,CAAAC,QAAS,CAAK,YAAQ,KAAK,CAAC,GAAArB,EAAA,CAAAuB,MAAA,CAAAnC,IAAA,IAAAA,IAAA,CAAAwB,OAAA;IACxD,CAAsB;IACtB,MAAAY,iBAA0B,GAAAA,CAAA;MAC1BvD,YAAA,CAAAG,KAAsB,CAAAqD,OAAA,CAAArC,IAAA,IAAAA,IAAA,CAAA6B,OAAA;MACjBC,qBAAA,EAAkB;MACzBnD,KAAA,CAAAK,KAAA,GAAAL,KAAA,CAAAK,KAAA,CAAA+B,KAAA;MAEAnC,aAAA,CAAAI,KAAA;MACElB,IAAA,gBAAQ,IAAwB;IAChC;IACM,MAAAgE,qBAA2B,GAAAA,CAAA,KAAC;MAE5B,IAAAlB,EAAA;MACN,MAAM;QAAAc,aAAe;QAAAC;MAAK,IAAAvD,QAA2B,CAAAY,KAAA;MACrD,MAAAsD,QAAqB,GAAAzD,YAAA,CAAAG,KAAA;MACrB,MAAAuD,QAAqB,GAAAL,eAAW,CAAS,CAAAR,aAAA,CAAO;MAClD,MAAAc,KAAA,GAAAC,KAAA,CAAAC,mBAAA,CAAAJ,QAAA,EAAAC,QAAA;MAEA,MAAyBI,MAAA,GAAAH,KAAA,CAAAI,GAAC,CAAS5C,IAAA,IAAAA,IAAA,CAAO6C,aAAmB;MACrDhE,YAAA,CAAAG,KAAA,GAAiBwD,KAAA;MACvB9D,YAAQ,CAAAM,KAAgB,GAAA2C,QAAA,GAAAgB,MAAc,IAAI/B,EAAO,GAAA+B,MAAA,eAAA/B,EAAA;IACjD;IAGE,MAAAf,gBACA,GAAAA,CAAAW,MAAA,UAAAsC,MACE,GAAU;MAEZ;QAAAC;MAAA,IAAA/F,KAAA;MAEE;QAAAwC,IAAQ;QAASmC,QAAA;QAAAD;MAAA,IAAAtD,QAAA,CAAAY,KAAA;MACnB,MAAAiD,QAAoC,IAAAP,aAAA;MAClC,KAAAnD,aAAsB,CAAAS,KAAA,IAAAhB,aAAW,KAAA8E,MAAA,IAAAE,aAAA,CAAAC,OAAA,CAAAF,UAAA,EAAArE,YAAA,CAAAM,KAAA,GACnC;MACM,IAAAQ,IAAA,KAAAgB,MAAA;QAIN,MAAAmC,MAAkB,GAAAO,MAAA,CAAAC,MAAA,CAAAH,aAAA,CAAAI,WAAA,CAAAF,MAAA,CAAAG,SAAA,CAAAN,UAAA;QACV,MAAAP,KAAA,GAAAG,MAAkB,CAAAC,GAAA,CAAAU,GAAA,IAAAhF,OAAA,oBAAAA,OAAA,CAAAiF,cAAA,CAAAD,GAAA,GAAAnB,MAAA,CAAAnC,IAAA,MAAAA,IAAA,KAAAA,IAAA,CAAAQ,MAAA,KAAAR,IAAA,CAAAC,OAAA;QACtB,IAAAuC,KAAA,CAAAgB,MAAe;UACjBhB,KAAC,CAAAH,OAAA,CAAArC,IAAA;YACIL,QAAA,CAAAK,IAAA,QAAAH,gBAAA,QAAAiD,MAAA;UACL;QAA6B,CAC/B;UACKjD,gBAAA,OAAAiD,MAAA;QACL;MACA;QACE,MAAAH,MAAA,GAAYhB,QAAA,GAAAuB,MAAA,CAAAG,SAA8B,CAAAN,UAAA,KAAAA,UAAc;QAC1D,MAAAP,KAAA,GAAAU,MAAA,CAAAC,MAAA,CAAAR,MAAA,CAAAC,GAAA,CAAAU,GAAA,IAAAhF,OAAA,oBAAAA,OAAA,CAAAiF,cAAA,CAAAD,GAAA,EAAArB,QAAA;QACAwB,aAAA,CAAcjB,KAAA,EAAOM,MAAM;QACdpE,YAAA,CAAAM,KAAA,GAAQgE,aAAA,CAAAU,SAAA,CAAUX,UAAU;MAAA;IAC3C,CACF;IAEA,MAAMU,aAAgB,GAAAA,CACpBE,eACA,EAAAC,qBAAA,GAAwB,IACrB;MACG;QAAElC;MAAc,IAAItD,QAAO,CAAAY,KAAA;MACjC,MAAMsD,QAAA,GAAWzD,YAAa,CAAAG,KAAA;MAC9B,MAAMuD,QAAA,GAAWoB,eAAgB,CAAAxB,MAAA,CAAAnC,IAAA,MAAAA,IAAA,KAAA0B,aAAA,IAAA1B,IAAA,CAAAiB,MAAA;MAAA,MACrB4C,gBAAE,GAAAvF,OAAA,WAA+B,SAAAA,OAAA,CAAAwF,WAAA,CAAAlF,aAAA,CAAAI,KAAA;MAC7C,MAAAgC,gBAAA,GAAA4C,qBAAA,IAAAC,gBAAA,IAAAtB,QAAA;MACA,IAAAvB,gBAAyB;QACzBA,gBACG,CAAAE,SAAA,CAAAmB,OAAA,CAAArC,IAAA,IAAAU,UAA8C,CAAAV,IAAA;MAEjD,OAAsB;QACpBpB,aAAA,CAAAI,KAAA;MAAmE;MAEnEsD,QAAA,CAAAD,OAAc,CAAQrC,IAAA,IAAAA,IAAA,CAAA6B,OAAA;MACxBnF,GAAA,CAAAqH,QAAA,CAAAxB,QAAA,EAAAF,OAAA,CAAArC,IAAA,IAAAA,IAAA,CAAA6B,OAAA;MAEAhD,YAAA,CAAAG,KAAkB,GAAAuD,QAAc;MACvB7F,GAAA,CAAAsH,QAAA,CAAAC,qBAAA;IACT;IACA,MAAAA,qBAA8B,GAAAA,CAAA;MAChC,KAAAC,IAAA,CAAAC,QAAA,EAEA;MACE1F,QAAe,CAAAO,KAAA,CAAAqD,OAAA,CAAAtF,IAAA;QAEN,MAAAqH,WAAc,GAAArH,IAAU,oBAAAA,IAAA,CAAAsH,GAAA;QAC/B,IAAAD,WAAA;UACA,MAAiBE,SAAA,GAAAF,WAAA,CAAAG,aAAA,KAAAtG,EAAA,CAAAuG,SAAA,CAAAxF,KAAA;UACf,MAAMyF,UAAA,GAAwBL,WAAA,CAAAG,aAAA,KAAAtG,EAAA,CAAAyG,CAAA,YAAAzG,EAAA,CAAA0G,EAAA,iBAAAP,WAAA,CAAAG,aAAA,KAAAtG,EAAA,CAAAyG,CAAA;UAC5BE,MAAA,CAAAC,cAAO,CAAAP,SAAe,EAAAG,UAAA;QAAA;MAExB,CAAM;IAGN;IACF,MAAAK,aAAA,GAAAC,CAAA;MACF,MAACC,MAAA,GAAAD,CAAA,CAAAC,MAAA;MACH;QAAAC;MAAA,IAAAF,CAAA;MAEM,QAAAE,IAAA;QACJ,KAAAC,IAAA,CAAAC,UAAiB,CAAAC,EAAA;QACX,KAAAF,IAAA,CAAAC,UAAW,CAAAE,IAAA;UAAA;YAEjBN,CAAA,CAAAO,cAAc;YAAA,MACIC,QAAA,GAAAN,IAAA,KAAAC,IAAA,CAAAC,UAAA,CAAAC,EAAA;YAChBI,MAAA,CAAAC,SAAA,CAAAD,MAAA,CAAAE,UAAsB,CAAAV,MAAA,EAAAO,QAAA,MAAAtH,EAAA,CAAAyG,CAAA;YACpB;UACA;QACA,KAAAQ,IAAA,CAAAC,UAAA,CAAAQ,IAAA;UAAA;YACEZ,CAAA,CAAAO,cAAA;YACF,MAAAM,OAAA,GAAAnH,QAAA,CAAAO,KAAA,CAAAyD,KAAA,CAAAoD,YAAA,CAAAb,MAAA;YACA,MAAAc,YAAA,GAAAF,OAAA,oBAAAA,OAAA,CAAAvB,GAAA,CAAAE,aAAA,KAAAtG,EAAA,CAAAyG,CAAA;YACFc,MAAA,CAAAC,SAAA,CAAAK,YAAA;YACA;UACE;QACA,KAAAZ,IAAA,CAAAC,UAAA,CAAAY,KAAyB;UAAA;YACnBhB,CAAA,CAAAO,cAAA;YAA4B,MAC5BU,QAAK,GAAMvH,QAAC,CAAAO,KAAA,CAAAyD,KAAA,CAAAoD,YAAA,CAAAb,MAAA;YAClB,MAAAiB,SAAA,GAAAD,QAAA,oBAAAA,QAAA,CAAA3B,GAAA,CAAAE,aAAA,KAAAtG,EAAA,CAAAyG,CAAA;YACAc,MAAA,CAAAC,SAAA,CAAUQ,SAAY;YACtB;UAAA;QAEF,KAAKf,IAAA,CAAAC,UAAA,CAAWe,KAAO;QACrB,KAAiBhB,IAAA,CAAAC,UAAA,CAAAgB,WAAA;UACjB1D,KAAA,CAAA2D,SAAA,CAAApB,MAAA,CAAiB;UACX;MAA0B;IACd,CAClB;IACAtI,GAAA,CAAA2J,OAAA,CAAAC,KAAA,CAAAC,4BAAmB,EAAA7J,GAAA,CAAAqH,QAAA;MACnB9G,MAAA,EAAAmB,QAAA;MACFQ,aAAA;MAAAC,YACgB;MAAAC,WACA;MACdP,aAAA;MACAW,aAAA;MACJS,QAAA;MACFe,UAAA;MAEAa;IAAA,CACE;IAAA7E,GAAA,CAAA8J,KACS,EAAApI,QAAA,QAAApB,KAAA,CAAAoC,OAAA,GAAAD,SAAA;MACPsH,IAAA;MACAC,SAAA;IAAA,CACA;IACAhK,GAAA,CAAA8J,KAAA,OAAAxJ,KAAA,CAAA+F,UAAA;MACA/E,aAAA;MACA6B,gBAAA;IAAA,CACA;MACA4G,IAAA;IAAA,CACA;IAAA/J,GAAA,CAAA8J,KACD,OAAA9H,YAAA,CAAAM,KAAA,EAAAsE,GAAA;MACH,KAAAN,aAAA,CAAAC,OAAA,CAAAK,GAAA,EAAAtG,KAAA,CAAA+F,UAAA;QAEAjF,IAAe,CAAAJ,KAAA,CAAAC,kBAAY,EAAA2F,GAAA;QACnBxF,IAAA,CAAAJ,KAAA,CAAAE,YAAA,EAAA0F,GAAA;MAAA;IACK,CACZ;IAED5G,GAAA,CAAAiK,cAAA,OAAAlI,QAAA,CAAAO,KAAA;IAAAtC,GAAA,CAAAkK,SACc,QAAAnH,OAAA,CAAAC,OAAA,CAAA1C,KAAA,CAAA+F,UAAA,KAAAlD,gBAAA;IAAA,OACN;MACY5B,EAAA;MACCQ,QAAA;MACnBE,KAAA;MACAE,YAAA;MAAAiG,aACQ;MACRvD,iBAAA;MACFS,eAAA;MAEAE,eAAA;MACEE,iBAAmB;MACnBN,qBAAS;MACPmC;IACE;EACA;AAAsB,CACxB;AACF,SACF4C,YAAAC,IAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAC,KAAA,EAAAC,QAAA;EAEA,MAAAC,2BAAuC,GAAA1K,GAAA,CAAA2K,gBAAG;EAE1C,OAAA3K,GAAA,CAAA4K,SAAA,EAAiB,EAAA5K,GAAA,CAAA6K,kBAAwB,QAAK;IAEvCC,KAAA,EAAA9K,GAAA,CAAA+K,cAAA,EAAAX,IAAA,CAAA7I,EAAA,CAAAyG,CAAA,WAAAoC,IAAA,CAAA7I,EAAA,CAAA0G,EAAA,aAAAmC,IAAA,CAAA3J,MAAA;IACLuK,SAAA,EAAAZ,IAAA,CAAAhC;EAAA,CACA,IACApI,GAAA,CAAA4K,SAAA,QAAA5K,GAAA,CAAA6K,kBAAA,CAAA7K,GAAA,CAAAiL,QAAA,QAAAjL,GAAA,CAAAkL,UAAA,CAAAd,IAAA,CAAAnI,KAAA,GAAA5B,IAAA,EAAAmB,KAAA;IACA,OAAAxB,GAAA,CAAA4K,SAAA,IAAA5K,GAAA,CAAAmL,WAAA,CAAAT,2BAAA;MACAU,GAAA,EAAA5J,KAAA;MACA6J,OAAA;MACAvJ,GAAA,EAAAwJ,IAAA,IAAAlB,IAAA,CAAArI,QAAA,CAAAP,KAAA,IAAA8J,IAAA;MAAA9J,KAAA;MAAAsE,KAAA,MAAAzF,IAAA;IAAA;MAIAkL,KAAA,EAAAvL,GAAA,CAAAwL,OAAA,QAAAxL,GAAA,CAAAyL,UAAA,CAAArB,IAAA,CAAAsB,MAAA;MAAAC,CAAA;IAAA,CAIA;EAAA,CACA,SACA;AAAA;AAGN,IAAAC,aAAA,GAAC,eAAAC,sBAAA,YAAA9L,SAAA,cAAAoK,WAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}